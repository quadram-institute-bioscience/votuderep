{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"votuderep","text":"<p>A Python CLI tool for dereplicating and filtering viral contigs (vOTUs - viral Operational Taxonomic Units) using the CheckV method.</p>"},{"location":"#overview","title":"Overview","text":"<p>votuderep is a small toolkit developed for the EBAME workshop with subcommands for working with viral sequences:</p> <ul> <li>derep: Remove redundant viral sequences using BLAST-based ANI clustering</li> <li>filter: Filter viral contigs based on quality, completeness, and other metrics from CheckV tsv output</li> <li>getdbs: Download geNomad, CheckV, and PHROGs databases</li> <li>tabulate: Generate CSV tables from paired-end sequencing read directories (for nextflow)</li> <li>trainingdata: Fetch viral assembly datasets for training purposes</li> <li>splitcoverm: Split a CoverM TSV by metric into separate TSVs, one per metric</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python &gt;= 3.10</li> <li>BLAST+ toolkit (specifically <code>blastn</code> and <code>makeblastdb</code>)</li> </ul>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Installation Guide</li> <li>Quick Start Tutorial</li> <li>CLI Commands Overview</li> <li>API Reference</li> </ul>"},{"location":"#global-options","title":"Global Options","text":"<p>All commands support the following global options:</p> <ul> <li><code>-v, --verbose</code>: Enable verbose logging</li> <li><code>-h, --help</code>: Show help message (also <code>--help</code>)</li> <li><code>--version</code>: Show version and exit</li> </ul>"},{"location":"#license","title":"License","text":"<p>MIT License - See LICENSE file for details</p>"},{"location":"#authors","title":"Authors","text":"<p>Andrea Telatin &amp; QIB Core Bioinformatics</p> <p>\u00a9\ufe0f Quadram Institute Bioscience 2025</p>"},{"location":"api/","title":"API Reference","text":"<p>This page provides detailed API documentation for the votuderep Python package. You can use these modules programmatically in your own Python scripts.</p>"},{"location":"api/#package-information","title":"Package Information","text":""},{"location":"api/#votuderep","title":"<code>votuderep</code>","text":""},{"location":"api/#votuderep--votuderep-a-comprehensive-toolkit-for-viral-contig-dereplication-and-quality-filtering","title":"votuderep - A comprehensive toolkit for viral contig dereplication and quality filtering","text":"<p>votuderep is a command-line tool designed for processing viral metagenomics data, with a focus on dereplicating viral Operational Taxonomic Units (vOTUs) and filtering sequences based on quality metrics from CheckV.</p>"},{"location":"api/#votuderep--key-features","title":"Key Features","text":"<ul> <li>Dereplication: Cluster viral sequences by Average Nucleotide Identity (ANI) using BLAST</li> <li>Quality Filtering: Filter sequences based on CheckV quality assessment metrics</li> <li>Database Management: Download and manage geNomad and CheckV databases</li> <li>Utility Tools:</li> <li>Generate sample tables from sequencing read directories</li> <li>Split CoverM coverage tables by metric</li> <li>Download training datasets for tutorials</li> </ul>"},{"location":"api/#votuderep--installation","title":"Installation","text":"<p>Install votuderep using pip:</p> <pre><code>pip install votuderep\n</code></pre> <p>Or install from source:</p> <pre><code>git clone https://github.com/yourusername/votuderep.git\ncd votuderep\npip install -e .\n</code></pre>"},{"location":"api/#votuderep--quick-start","title":"Quick Start","text":""},{"location":"api/#votuderep--dereplicate-viral-contigs","title":"Dereplicate viral contigs","text":"<pre><code>votuderep derep -i viral_contigs.fasta -o dereplicated.fasta --min-ani 95 --min-tcov 85\n</code></pre>"},{"location":"api/#votuderep--filter-by-checkv-quality","title":"Filter by CheckV quality","text":"<pre><code>votuderep filter contigs.fasta checkv_output.tsv -o filtered.fasta --min-quality medium\n</code></pre>"},{"location":"api/#votuderep--download-databases","title":"Download databases","text":"<pre><code>votuderep getdbs --outdir ./databases\n</code></pre>"},{"location":"api/#votuderep--generate-sample-table","title":"Generate sample table","text":"<pre><code>votuderep tabulate reads_directory/ -o samples.csv\n</code></pre>"},{"location":"api/#votuderep--available-commands","title":"Available Commands","text":"<p>Run <code>votuderep --help</code> to see all available commands:</p> <ul> <li>derep: Dereplicate vOTUs using BLAST and ANI clustering</li> <li>filter: Filter FASTA files using CheckV quality metrics</li> <li>getdbs: Download geNomad and CheckV databases</li> <li>splitcoverm: Split CoverM TSV by metric into separate files</li> <li>tabulate: Generate CSV file from a directory containing reads</li> <li>trainingdata: Download training datasets</li> </ul>"},{"location":"api/#votuderep--module-organization","title":"Module Organization","text":"<ul> <li><code>votuderep.commands</code>: CLI command implementations</li> <li><code>votuderep.core</code>: Core business logic (BLAST, ANI calculation, filtering)</li> <li><code>votuderep.utils</code>: Utility functions (I/O, validation, logging)</li> </ul>"},{"location":"api/#votuderep--requirements","title":"Requirements","text":"<ul> <li>Python &gt;= 3.10</li> <li>BLAST+ toolkit (for dereplication)</li> <li>Dependencies: click, rich, pandas, pyfastx</li> </ul>"},{"location":"api/#votuderep--citation","title":"Citation","text":"<p>If you use votuderep in your research, please cite:</p> <pre><code>Telatin, A. et al. (2024). votuderep: A tool for viral contig dereplication.\n</code></pre>"},{"location":"api/#votuderep--license","title":"License","text":"<p>MIT License - see LICENSE file for details</p>"},{"location":"api/#votuderep--version-information","title":"Version Information","text":""},{"location":"api/#votuderep.__version__","title":"<code>__version__ = '0.6.0'</code>  <code>module-attribute</code>","text":""},{"location":"api/#core-modules","title":"Core Modules","text":""},{"location":"api/#dereplication","title":"Dereplication","text":"<p>The dereplication module handles ANI-based clustering of viral sequences.</p>"},{"location":"api/#votuderep.core.dereplication","title":"<code>votuderep.core.dereplication</code>","text":"<p>ANI calculation and clustering for vOTU dereplication.</p>"},{"location":"api/#votuderep.core.dereplication.parse_blast_line","title":"<code>parse_blast_line(line)</code>","text":"<p>Parse a single BLAST output line (format: '6 std qlen slen').</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>str</code> <p>BLAST output line</p> required <p>Returns:</p> Type Description <code>Dict</code> <p>Dictionary with parsed BLAST fields</p> Source code in <code>src/votuderep/core/dereplication.py</code> <pre><code>def parse_blast_line(line: str) -&gt; Dict:\n    \"\"\"\n    Parse a single BLAST output line (format: '6 std qlen slen').\n\n    Args:\n        line: BLAST output line\n\n    Returns:\n        Dictionary with parsed BLAST fields\n    \"\"\"\n    fields = line.strip().split(\"\\t\")\n    return {\n        \"qname\": fields[0],\n        \"tname\": fields[1],\n        \"pid\": float(fields[2]),\n        \"len\": float(fields[3]),\n        \"qcoords\": sorted([int(fields[6]), int(fields[7])]),\n        \"tcoords\": sorted([int(fields[8]), int(fields[9])]),\n        \"qlen\": float(fields[12]),\n        \"tlen\": float(fields[13]),\n        \"evalue\": float(fields[10]),\n    }\n</code></pre>"},{"location":"api/#votuderep.core.dereplication.yield_alignment_blocks","title":"<code>yield_alignment_blocks(blast_file)</code>","text":"<p>Group BLAST alignments by query-target pair.</p> <p>Parameters:</p> Name Type Description Default <code>blast_file</code> <code>str</code> <p>Path to BLAST output file</p> required <p>Yields:</p> Type Description <code>List[Dict]</code> <p>List of alignments for each query-target pair</p> Source code in <code>src/votuderep/core/dereplication.py</code> <pre><code>def yield_alignment_blocks(blast_file: str) -&gt; Iterator[List[Dict]]:\n    \"\"\"\n    Group BLAST alignments by query-target pair.\n\n    Args:\n        blast_file: Path to BLAST output file\n\n    Yields:\n        List of alignments for each query-target pair\n    \"\"\"\n    handle = gzip.open(blast_file, \"rt\") if blast_file.endswith(\".gz\") else open(blast_file)\n\n    try:\n        # Initialize with first record\n        first_line = next(handle)\n        first_aln = parse_blast_line(first_line)\n        key = (first_aln[\"qname\"], first_aln[\"tname\"])\n        alns = [first_aln]\n\n        # Loop over remaining records\n        for line in handle:\n            aln = parse_blast_line(line)\n            current_key = (aln[\"qname\"], aln[\"tname\"])\n\n            # Extend current block\n            if current_key == key:\n                alns.append(aln)\n            # Yield current block and start new one\n            else:\n                yield alns\n                key = current_key\n                alns = [aln]\n\n        # Yield last block\n        if alns:\n            yield alns\n    finally:\n        handle.close()\n</code></pre>"},{"location":"api/#votuderep.core.dereplication.prune_alignments","title":"<code>prune_alignments(alns, min_length=0, min_evalue=0.001)</code>","text":"<p>Remove low-quality alignments and those beyond query coverage.</p> <p>Parameters:</p> Name Type Description Default <code>alns</code> <code>List[Dict]</code> <p>List of alignments for a query-target pair</p> required <code>min_length</code> <code>int</code> <p>Minimum alignment length</p> <code>0</code> <code>min_evalue</code> <code>float</code> <p>Maximum E-value</p> <code>0.001</code> <p>Returns:</p> Type Description <code>List[Dict]</code> <p>Pruned list of alignments</p> Source code in <code>src/votuderep/core/dereplication.py</code> <pre><code>def prune_alignments(alns: List[Dict], min_length: int = 0, min_evalue: float = 1e-3) -&gt; List[Dict]:\n    \"\"\"\n    Remove low-quality alignments and those beyond query coverage.\n\n    Args:\n        alns: List of alignments for a query-target pair\n        min_length: Minimum alignment length\n        min_evalue: Maximum E-value\n\n    Returns:\n        Pruned list of alignments\n    \"\"\"\n    keep = []\n    cur_aln = 0\n    qry_len = alns[0][\"qlen\"]\n\n    for aln in alns:\n        qcoords = aln[\"qcoords\"]\n        aln_len = max(qcoords) - min(qcoords) + 1\n\n        # Filter by length and e-value\n        if aln_len &lt; min_length or aln[\"evalue\"] &gt; min_evalue:\n            continue\n\n        # Stop if we've covered the query or exceeded 110% of query length\n        if cur_aln &gt;= qry_len or aln_len + cur_aln &gt;= 1.10 * qry_len:\n            break\n\n        keep.append(aln)\n        cur_aln += aln_len\n\n    return keep\n</code></pre>"},{"location":"api/#votuderep.core.dereplication.compute_ani","title":"<code>compute_ani(alns)</code>","text":"<p>Compute average nucleotide identity (ANI) from alignments.</p> <p>Parameters:</p> Name Type Description Default <code>alns</code> <code>List[Dict]</code> <p>List of alignments</p> required <p>Returns:</p> Type Description <code>float</code> <p>ANI as a percentage (0-100)</p> Source code in <code>src/votuderep/core/dereplication.py</code> <pre><code>def compute_ani(alns: List[Dict]) -&gt; float:\n    \"\"\"\n    Compute average nucleotide identity (ANI) from alignments.\n\n    Args:\n        alns: List of alignments\n\n    Returns:\n        ANI as a percentage (0-100)\n    \"\"\"\n    weighted_sum = sum(a[\"len\"] * a[\"pid\"] for a in alns)\n    total_len = sum(a[\"len\"] for a in alns)\n    return round(weighted_sum / total_len, 2) if total_len &gt; 0 else 0.0\n</code></pre>"},{"location":"api/#votuderep.core.dereplication.compute_coverage","title":"<code>compute_coverage(alns)</code>","text":"<p>Compute query and target coverage from alignments.</p> <p>Parameters:</p> Name Type Description Default <code>alns</code> <code>List[Dict]</code> <p>List of alignments</p> required <p>Returns:</p> Type Description <code>Tuple[float, float]</code> <p>Tuple of (query_coverage, target_coverage) as percentages</p> Source code in <code>src/votuderep/core/dereplication.py</code> <pre><code>def compute_coverage(alns: List[Dict]) -&gt; Tuple[float, float]:\n    \"\"\"\n    Compute query and target coverage from alignments.\n\n    Args:\n        alns: List of alignments\n\n    Returns:\n        Tuple of (query_coverage, target_coverage) as percentages\n    \"\"\"\n    # Merge query coordinates\n    qcoords = sorted([a[\"qcoords\"] for a in alns])\n    nr_qcoords = [qcoords[0][:]]  # Copy first coord pair\n\n    for start, stop in qcoords[1:]:\n        # Overlapping, update stop coord\n        if start &lt;= nr_qcoords[-1][1] + 1:\n            nr_qcoords[-1][1] = max(nr_qcoords[-1][1], stop)\n        # Non-overlapping, append\n        else:\n            nr_qcoords.append([start, stop])\n\n    # Compute query coverage\n    qlen = sum(stop - start + 1 for start, stop in nr_qcoords)\n    qcov = round(100.0 * qlen / alns[0][\"qlen\"], 2)\n\n    # Merge target coordinates\n    tcoords = sorted([a[\"tcoords\"] for a in alns])\n    nr_tcoords = [tcoords[0][:]]  # Copy first coord pair\n\n    for start, stop in tcoords[1:]:\n        # Overlapping, update stop coord\n        if start &lt;= nr_tcoords[-1][1] + 1:\n            nr_tcoords[-1][1] = max(nr_tcoords[-1][1], stop)\n        # Non-overlapping, append\n        else:\n            nr_tcoords.append([start, stop])\n\n    # Compute target coverage\n    tlen = sum(stop - start + 1 for start, stop in nr_tcoords)\n    tcov = round(100.0 * tlen / alns[0][\"tlen\"], 2)\n\n    return qcov, tcov\n</code></pre>"},{"location":"api/#votuderep.core.dereplication.calculate_ani","title":"<code>calculate_ani(blast_file, output_file, min_length=0)</code>","text":"<p>Calculate ANI and coverage from BLAST results.</p> <p>Parameters:</p> Name Type Description Default <code>blast_file</code> <code>str</code> <p>Path to BLAST output file</p> required <code>output_file</code> <code>str</code> <p>Path to output ANI file</p> required <code>min_length</code> <code>int</code> <p>Minimum alignment length to keep</p> <code>0</code> <p>Creates a TSV file with columns: qname, tname, num_alns, pid, qcov, tcov</p> Source code in <code>src/votuderep/core/dereplication.py</code> <pre><code>def calculate_ani(blast_file: str, output_file: str, min_length: int = 0) -&gt; None:\n    \"\"\"\n    Calculate ANI and coverage from BLAST results.\n\n    Args:\n        blast_file: Path to BLAST output file\n        output_file: Path to output ANI file\n        min_length: Minimum alignment length to keep\n\n    Creates a TSV file with columns: qname, tname, num_alns, pid, qcov, tcov\n    \"\"\"\n    logger.info(\"Calculating ANI from BLAST results\")\n\n    handle = gzip.open(output_file, \"wt\") if output_file.endswith(\".gz\") else open(output_file, \"w\")\n\n    try:\n        # Write header\n        fields = [\"qname\", \"tname\", \"num_alns\", \"pid\", \"qcov\", \"tcov\"]\n        handle.write(\"\\t\".join(fields) + \"\\n\")\n\n        count = 0\n        for alns in yield_alignment_blocks(blast_file):\n            alns = prune_alignments(alns, min_length=min_length)\n\n            if len(alns) == 0:\n                continue\n\n            qname, tname = alns[0][\"qname\"], alns[0][\"tname\"]\n            ani = compute_ani(alns)\n            qcov, tcov = compute_coverage(alns)\n\n            row = [qname, tname, len(alns), ani, qcov, tcov]\n            handle.write(\"\\t\".join(str(x) for x in row) + \"\\n\")\n            count += 1\n\n        logger.info(f\"Calculated ANI for {count} sequence pairs\")\n    finally:\n        handle.close()\n</code></pre>"},{"location":"api/#votuderep.core.dereplication.cluster_by_ani","title":"<code>cluster_by_ani(fasta_file, ani_file, min_ani=95.0, min_qcov=0.0, min_tcov=85.0, min_length=1)</code>","text":"<p>Cluster sequences by ANI using centroid-based clustering.</p> <p>Parameters:</p> Name Type Description Default <code>fasta_file</code> <code>str</code> <p>Path to input FASTA file</p> required <code>ani_file</code> <code>str</code> <p>Path to ANI file from calculate_ani</p> required <code>min_ani</code> <code>float</code> <p>Minimum ANI threshold (0-100)</p> <code>95.0</code> <code>min_qcov</code> <code>float</code> <p>Minimum query coverage (0-100)</p> <code>0.0</code> <code>min_tcov</code> <code>float</code> <p>Minimum target coverage (0-100)</p> <code>85.0</code> <code>min_length</code> <code>int</code> <p>Minimum sequence length</p> <code>1</code> <p>Returns:</p> Type Description <code>Dict[str, List[str]]</code> <p>Dictionary mapping centroid IDs to lists of member IDs</p> Source code in <code>src/votuderep/core/dereplication.py</code> <pre><code>def cluster_by_ani(\n    fasta_file: str,\n    ani_file: str,\n    min_ani: float = 95.0,\n    min_qcov: float = 0.0,\n    min_tcov: float = 85.0,\n    min_length: int = 1,\n) -&gt; Dict[str, List[str]]:\n    \"\"\"\n    Cluster sequences by ANI using centroid-based clustering.\n\n    Args:\n        fasta_file: Path to input FASTA file\n        ani_file: Path to ANI file from calculate_ani\n        min_ani: Minimum ANI threshold (0-100)\n        min_qcov: Minimum query coverage (0-100)\n        min_tcov: Minimum target coverage (0-100)\n        min_length: Minimum sequence length\n\n    Returns:\n        Dictionary mapping centroid IDs to lists of member IDs\n    \"\"\"\n    logger.info(\"Clustering sequences by ANI\")\n\n    # Read sequences, sorted by length (longest first)\n    logger.debug(\"Reading sequences\")\n    seqs = {}\n    for seq_id, seq in read_fasta(fasta_file):\n        if len(seq) &gt;= min_length:\n            seqs[seq_id] = len(seq)\n\n    # Sort by length descending\n    sorted_seqs = [x[0] for x in sorted(seqs.items(), key=lambda x: x[1], reverse=True)]\n    logger.info(f\"Loaded {len(sorted_seqs)} sequences\")\n\n    # Build edges from ANI file\n    logger.debug(\"Building edges from ANI comparisons\")\n    edges = {seq_id: [] for seq_id in sorted_seqs}\n    num_edges = 0\n\n    handle = gzip.open(ani_file, \"rt\") if ani_file.endswith(\".gz\") else open(ani_file)\n\n    try:\n        # Skip header\n        next(handle)\n\n        for line in handle:\n            fields = line.strip().split(\"\\t\")\n            qname, tname = fields[0], fields[1]\n            ani, qcov, tcov = (\n                float(fields[3]),\n                float(fields[4]),\n                float(fields[5]),\n            )\n\n            # Skip self-matches\n            if qname == tname:\n                continue\n\n            # Skip if not in our sequence set\n            if qname not in edges or tname not in edges:\n                continue\n\n            # Apply thresholds\n            if qcov &lt; min_qcov or tcov &lt; min_tcov or ani &lt; min_ani:\n                continue\n\n            edges[qname].append(tname)\n            num_edges += 1\n    finally:\n        handle.close()\n\n    logger.info(f\"Loaded {num_edges} edges passing thresholds\")\n\n    # Perform greedy clustering\n    logger.debug(\"Performing greedy clustering\")\n    clust_to_seqs = {}\n    seq_to_clust = {}\n\n    for seq_id in sorted_seqs:\n        # Already assigned to a cluster\n        if seq_id in seq_to_clust:\n            continue\n\n        # Create new cluster with seq_id as centroid\n        clust_to_seqs[seq_id] = [seq_id]\n        seq_to_clust[seq_id] = seq_id\n\n        # Add cluster members\n        for member_id in edges[seq_id]:\n            if member_id not in seq_to_clust:\n                clust_to_seqs[seq_id].append(member_id)\n                seq_to_clust[member_id] = seq_id\n\n    logger.info(f\"Created {len(clust_to_seqs)} clusters\")\n\n    return clust_to_seqs\n</code></pre>"},{"location":"api/#votuderep.core.dereplication.dereplicate_sequences","title":"<code>dereplicate_sequences(fasta_file, blast_file, output_ani, min_ani=95.0, min_tcov=85.0)</code>","text":"<p>Dereplicate sequences by ANI clustering.</p> <p>Parameters:</p> Name Type Description Default <code>fasta_file</code> <code>str</code> <p>Path to input FASTA file</p> required <code>blast_file</code> <code>str</code> <p>Path to BLAST output file</p> required <code>output_ani</code> <code>str</code> <p>Path to output ANI file</p> required <code>min_ani</code> <code>float</code> <p>Minimum ANI threshold (0-100)</p> <code>95.0</code> <code>min_tcov</code> <code>float</code> <p>Minimum target coverage (0-100)</p> <code>85.0</code> <p>Returns:</p> Type Description <code>Set[str]</code> <p>Set of sequence IDs representing cluster centroids (to keep)</p> Source code in <code>src/votuderep/core/dereplication.py</code> <pre><code>def dereplicate_sequences(\n    fasta_file: str, blast_file: str, output_ani: str, min_ani: float = 95.0, min_tcov: float = 85.0\n) -&gt; Set[str]:\n    \"\"\"\n    Dereplicate sequences by ANI clustering.\n\n    Args:\n        fasta_file: Path to input FASTA file\n        blast_file: Path to BLAST output file\n        output_ani: Path to output ANI file\n        min_ani: Minimum ANI threshold (0-100)\n        min_tcov: Minimum target coverage (0-100)\n\n    Returns:\n        Set of sequence IDs representing cluster centroids (to keep)\n    \"\"\"\n    # Calculate ANI\n    calculate_ani(blast_file, output_ani)\n\n    # Cluster sequences\n    clusters = cluster_by_ani(fasta_file, output_ani, min_ani=min_ani, min_tcov=min_tcov)\n\n    # Return centroid IDs\n    return set(clusters.keys())\n</code></pre>"},{"location":"api/#blast-operations","title":"BLAST Operations","text":"<p>The BLAST module provides utilities for running and parsing BLAST results.</p>"},{"location":"api/#votuderep.core.blast","title":"<code>votuderep.core.blast</code>","text":"<p>BLAST operations for vOTU dereplication.</p>"},{"location":"api/#votuderep.core.blast.run_makeblastdb","title":"<code>run_makeblastdb(input_fasta, output_db, dbtype='nucl')</code>","text":"<p>Create a BLAST database from a FASTA file.</p> <p>Parameters:</p> Name Type Description Default <code>input_fasta</code> <code>str</code> <p>Path to input FASTA file</p> required <code>output_db</code> <code>str</code> <p>Path prefix for output database</p> required <code>dbtype</code> <code>str</code> <p>Database type ('nucl' or 'prot')</p> <code>'nucl'</code> <p>Raises:</p> Type Description <code>VotuDerepError</code> <p>If makeblastdb fails</p> Source code in <code>src/votuderep/core/blast.py</code> <pre><code>def run_makeblastdb(input_fasta: str, output_db: str, dbtype: str = \"nucl\") -&gt; None:\n    \"\"\"\n    Create a BLAST database from a FASTA file.\n\n    Args:\n        input_fasta: Path to input FASTA file\n        output_db: Path prefix for output database\n        dbtype: Database type ('nucl' or 'prot')\n\n    Raises:\n        VotuDerepError: If makeblastdb fails\n    \"\"\"\n    cmd = [\"makeblastdb\", \"-in\", input_fasta, \"-dbtype\", dbtype, \"-out\", output_db]\n\n    logger.info(f\"Creating BLAST database: {output_db}\")\n    logger.debug(f\"Command: {' '.join(cmd)}\")\n\n    try:\n        result = subprocess.run(cmd, check=True, capture_output=True, text=True)\n        logger.debug(f\"makeblastdb output: {result.stdout}\")\n    except subprocess.CalledProcessError as e:\n        logger.error(f\"makeblastdb failed: {e.stderr}\")\n        raise VotuDerepError(f\"Failed to create BLAST database: {e.stderr}\")\n</code></pre>"},{"location":"api/#votuderep.core.blast.run_blastn","title":"<code>run_blastn(query, database, output, threads=2, max_target_seqs=10000, evalue=0.001)</code>","text":"<p>Run BLASTN for all-vs-all comparison.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>Path to query FASTA file</p> required <code>database</code> <code>str</code> <p>Path prefix to BLAST database</p> required <code>output</code> <code>str</code> <p>Path to output file</p> required <code>threads</code> <code>int</code> <p>Number of threads to use</p> <code>2</code> <code>max_target_seqs</code> <code>int</code> <p>Maximum number of target sequences</p> <code>10000</code> <code>evalue</code> <code>float</code> <p>E-value threshold</p> <code>0.001</code> <p>Raises:</p> Type Description <code>VotuDerepError</code> <p>If blastn fails</p> Source code in <code>src/votuderep/core/blast.py</code> <pre><code>def run_blastn(\n    query: str,\n    database: str,\n    output: str,\n    threads: int = 2,\n    max_target_seqs: int = 10000,\n    evalue: float = 1e-3,\n) -&gt; None:\n    \"\"\"\n    Run BLASTN for all-vs-all comparison.\n\n    Args:\n        query: Path to query FASTA file\n        database: Path prefix to BLAST database\n        output: Path to output file\n        threads: Number of threads to use\n        max_target_seqs: Maximum number of target sequences\n        evalue: E-value threshold\n\n    Raises:\n        VotuDerepError: If blastn fails\n    \"\"\"\n    cmd = [\n        \"blastn\",\n        \"-query\",\n        query,\n        \"-db\",\n        database,\n        \"-out\",\n        output,\n        \"-outfmt\",\n        \"6 std qlen slen\",\n        \"-max_target_seqs\",\n        str(max_target_seqs),\n        \"-num_threads\",\n        str(threads),\n        \"-evalue\",\n        str(evalue),\n    ]\n\n    logger.info(f\"Running BLASTN with {threads} threads\")\n    logger.debug(f\"Command: {' '.join(cmd)}\")\n\n    try:\n        result = subprocess.run(cmd, check=True, capture_output=True, text=True)\n        if result.stdout:\n            logger.debug(f\"blastn output: {result.stdout}\")\n    except subprocess.CalledProcessError as e:\n        logger.error(f\"blastn failed: {e.stderr}\")\n        raise VotuDerepError(f\"Failed to run BLASTN: {e.stderr}\")\n\n    logger.info(f\"BLASTN results written to: {output}\")\n</code></pre>"},{"location":"api/#filtering","title":"Filtering","text":"<p>The filtering module handles quality-based filtering using CheckV metrics.</p>"},{"location":"api/#votuderep.core.filtering","title":"<code>votuderep.core.filtering</code>","text":"<p>Filtering sequences based on CheckV quality metrics.</p>"},{"location":"api/#votuderep.core.filtering.parse_quality_threshold","title":"<code>parse_quality_threshold(min_quality)</code>","text":"<p>Parse minimum quality threshold.</p> <p>Parameters:</p> Name Type Description Default <code>min_quality</code> <code>str</code> <p>One of 'low', 'medium', 'high'</p> required <p>Returns:</p> Type Description <code>int</code> <p>Minimum quality level value</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If min_quality is invalid</p> Source code in <code>src/votuderep/core/filtering.py</code> <pre><code>def parse_quality_threshold(min_quality: str) -&gt; int:\n    \"\"\"\n    Parse minimum quality threshold.\n\n    Args:\n        min_quality: One of 'low', 'medium', 'high'\n\n    Returns:\n        Minimum quality level value\n\n    Raises:\n        ValueError: If min_quality is invalid\n    \"\"\"\n    quality_map = {\n        \"low\": 2,  # Low-quality, Medium-quality, High-quality, Complete\n        \"medium\": 3,  # Medium-quality, High-quality, Complete\n        \"high\": 4,  # High-quality, Complete\n    }\n\n    if min_quality not in quality_map:\n        raise ValueError(\n            f\"Invalid min_quality: {min_quality}. \"\n            f\"Must be one of: {', '.join(quality_map.keys())}\"\n        )\n\n    return quality_map[min_quality]\n</code></pre>"},{"location":"api/#votuderep.core.filtering.filter_by_checkv","title":"<code>filter_by_checkv(checkv_file, min_len=0, max_len=0, provirus_only=False, min_completeness=None, max_contam=None, no_warnings=False, exclude_undetermined=False, complete_only=False, min_quality='low')</code>","text":"<p>Filter sequence IDs based on CheckV quality metrics.</p> <p>Parameters:</p> Name Type Description Default <code>checkv_file</code> <code>str</code> <p>Path to CheckV TSV output file</p> required <code>min_len</code> <code>int</code> <p>Minimum contig length (0 = no minimum)</p> <code>0</code> <code>max_len</code> <code>int</code> <p>Maximum contig length (0 = no maximum)</p> <code>0</code> <code>provirus_only</code> <code>bool</code> <p>Only keep proviruses (provirus == \"Yes\")</p> <code>False</code> <code>min_completeness</code> <code>Optional[float]</code> <p>Minimum completeness percentage</p> <code>None</code> <code>max_contam</code> <code>Optional[float]</code> <p>Maximum contamination percentage</p> <code>None</code> <code>no_warnings</code> <code>bool</code> <p>Only keep contigs with no warnings</p> <code>False</code> <code>exclude_undetermined</code> <code>bool</code> <p>Exclude contigs with checkv_quality == \"Not-determined\"</p> <code>False</code> <code>complete_only</code> <code>bool</code> <p>Only keep contigs with checkv_quality == \"Complete\"</p> <code>False</code> <code>min_quality</code> <code>str</code> <p>Minimum quality level ('low', 'medium', 'high')</p> <code>'low'</code> <p>Returns:</p> Type Description <code>Set[str]</code> <p>Set of sequence IDs that pass all filters</p> Source code in <code>src/votuderep/core/filtering.py</code> <pre><code>def filter_by_checkv(\n    checkv_file: str,\n    min_len: int = 0,\n    max_len: int = 0,\n    provirus_only: bool = False,\n    min_completeness: Optional[float] = None,\n    max_contam: Optional[float] = None,\n    no_warnings: bool = False,\n    exclude_undetermined: bool = False,\n    complete_only: bool = False,\n    min_quality: str = \"low\",\n) -&gt; Set[str]:\n    \"\"\"\n    Filter sequence IDs based on CheckV quality metrics.\n\n    Args:\n        checkv_file: Path to CheckV TSV output file\n        min_len: Minimum contig length (0 = no minimum)\n        max_len: Maximum contig length (0 = no maximum)\n        provirus_only: Only keep proviruses (provirus == \"Yes\")\n        min_completeness: Minimum completeness percentage\n        max_contam: Maximum contamination percentage\n        no_warnings: Only keep contigs with no warnings\n        exclude_undetermined: Exclude contigs with checkv_quality == \"Not-determined\"\n        complete_only: Only keep contigs with checkv_quality == \"Complete\"\n        min_quality: Minimum quality level ('low', 'medium', 'high')\n\n    Returns:\n        Set of sequence IDs that pass all filters\n    \"\"\"\n    logger.info(f\"Loading CheckV results from: {checkv_file}\")\n\n    # Read CheckV file\n    df = pd.read_csv(checkv_file, sep=\"\\t\")\n    initial_count = len(df)\n    logger.info(f\"Loaded {initial_count} contigs from CheckV file\")\n\n    # Apply length filters\n    if min_len &gt; 0:\n        before = len(df)\n        df = df[df[\"contig_length\"] &gt;= min_len]\n        logger.debug(f\"Min length filter ({min_len}): {before} -&gt; {len(df)}\")\n\n    if max_len &gt; 0:\n        before = len(df)\n        df = df[df[\"contig_length\"] &lt;= max_len]\n        logger.debug(f\"Max length filter ({max_len}): {before} -&gt; {len(df)}\")\n\n    # Provirus filter\n    if provirus_only:\n        before = len(df)\n        df = df[df[\"provirus\"] == \"Yes\"]\n        logger.debug(f\"Provirus filter: {before} -&gt; {len(df)}\")\n\n    # Completeness filter\n    if min_completeness is not None:\n        before = len(df)\n        # Handle NaN values - keep only rows with completeness &gt;= threshold\n        df = df[df[\"completeness\"].notna() &amp; (df[\"completeness\"] &gt;= min_completeness)]\n        logger.debug(f\"Min completeness filter ({min_completeness}%): {before} -&gt; {len(df)}\")\n\n    # Contamination filter\n    if max_contam is not None:\n        before = len(df)\n        # Handle NaN values - keep rows with contamination &lt;= threshold or NaN\n        df = df[df[\"contamination\"].isna() | (df[\"contamination\"] &lt;= max_contam)]\n        logger.debug(f\"Max contamination filter ({max_contam}%): {before} -&gt; {len(df)}\")\n\n    # Warnings filter\n    if no_warnings:\n        before = len(df)\n        # Keep only rows where warnings is empty/NaN\n        df = df[df[\"warnings\"].isna() | (df[\"warnings\"] == \"\")]\n        logger.debug(f\"No warnings filter: {before} -&gt; {len(df)}\")\n\n    # Complete only filter\n    if complete_only:\n        before = len(df)\n        df = df[df[\"checkv_quality\"] == \"Complete\"]\n        logger.debug(f\"Complete only filter: {before} -&gt; {len(df)}\")\n    else:\n        # Quality level filter\n        min_quality_level = parse_quality_threshold(min_quality)\n\n        # Map quality to numeric values\n        df[\"quality_level\"] = df[\"checkv_quality\"].map(QUALITY_LEVELS)\n\n        # Apply quality filter\n        before = len(df)\n        df = df[df[\"quality_level\"] &gt;= min_quality_level]\n        logger.debug(f\"Min quality filter ({min_quality}): {before} -&gt; {len(df)}\")\n\n        # Exclude undetermined if requested\n        if exclude_undetermined:\n            before = len(df)\n            df = df[df[\"checkv_quality\"] != \"Not-determined\"]\n            logger.debug(f\"Exclude undetermined filter: {before} -&gt; {len(df)}\")\n\n    final_count = len(df)\n    logger.info(\n        f\"Filtering complete: {initial_count} -&gt; {final_count} contigs ({final_count/initial_count*100:.1f}%)\"\n    )\n\n    # Return set of contig IDs\n    return set(df[\"contig_id\"].tolist())\n</code></pre>"},{"location":"api/#utility-modules","title":"Utility Modules","text":""},{"location":"api/#io-operations","title":"I/O Operations","text":"<p>File input/output utilities for reading and writing sequences.</p>"},{"location":"api/#votuderep.utils.io","title":"<code>votuderep.utils.io</code>","text":"<p>I/O utilities for reading and writing FASTA files.</p>"},{"location":"api/#votuderep.utils.io.read_fasta","title":"<code>read_fasta(file_path)</code>","text":"<p>Read sequences from a FASTA file using pyfastx.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to FASTA file</p> required <p>Yields:</p> Type Description <code>Tuple[str, str]</code> <p>Tuple of (sequence_id, sequence)</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If pyfastx is not installed</p> <code>FileNotFoundError</code> <p>If file doesn't exist</p> Source code in <code>src/votuderep/utils/io.py</code> <pre><code>def read_fasta(file_path: str) -&gt; Iterator[Tuple[str, str]]:\n    \"\"\"\n    Read sequences from a FASTA file using pyfastx.\n\n    Args:\n        file_path: Path to FASTA file\n\n    Yields:\n        Tuple of (sequence_id, sequence)\n\n    Raises:\n        ImportError: If pyfastx is not installed\n        FileNotFoundError: If file doesn't exist\n    \"\"\"\n    if pyfastx is None:\n        raise ImportError(\n            \"pyfastx is required for reading FASTA files. \" \"Install it with: pip install pyfastx\"\n        )\n\n    path = Path(file_path)\n    if not path.exists():\n        raise FileNotFoundError(f\"FASTA file not found: {file_path}\")\n\n    # Use pyfastx to read FASTA file\n    for name, seq in pyfastx.Fastx(str(path)):\n        yield name, seq\n</code></pre>"},{"location":"api/#votuderep.utils.io.write_fasta","title":"<code>write_fasta(sequences, output_path=None, line_width=80)</code>","text":"<p>Write sequences to a FASTA file or stdout.</p> <p>Parameters:</p> Name Type Description Default <code>sequences</code> <code>Iterator[Tuple[str, str]]</code> <p>Iterator of (sequence_id, sequence) tuples</p> required <code>output_path</code> <code>Optional[str]</code> <p>Path to output file, or None for stdout</p> <code>None</code> <code>line_width</code> <code>int</code> <p>Number of characters per line (0 for no wrapping)</p> <code>80</code> <p>Raises:</p> Type Description <code>IOError</code> <p>If writing fails</p> Source code in <code>src/votuderep/utils/io.py</code> <pre><code>def write_fasta(\n    sequences: Iterator[Tuple[str, str]], output_path: Optional[str] = None, line_width: int = 80\n) -&gt; None:\n    \"\"\"\n    Write sequences to a FASTA file or stdout.\n\n    Args:\n        sequences: Iterator of (sequence_id, sequence) tuples\n        output_path: Path to output file, or None for stdout\n        line_width: Number of characters per line (0 for no wrapping)\n\n    Raises:\n        IOError: If writing fails\n    \"\"\"\n    # Determine output handle\n    if output_path is None or output_path == \"-\":\n        handle = sys.stdout\n        close_handle = False\n    else:\n        handle = open(output_path, \"w\")\n        close_handle = True\n\n    try:\n        for seq_id, sequence in sequences:\n            # Write header\n            handle.write(f\"&gt;{seq_id}\\n\")\n\n            # Write sequence with optional line wrapping\n            if line_width &gt; 0:\n                for i in range(0, len(sequence), line_width):\n                    handle.write(sequence[i : i + line_width] + \"\\n\")\n            else:\n                handle.write(sequence + \"\\n\")\n\n    finally:\n        if close_handle:\n            handle.close()\n</code></pre>"},{"location":"api/#votuderep.utils.io.count_sequences","title":"<code>count_sequences(file_path)</code>","text":"<p>Count the number of sequences in a FASTA file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to FASTA file</p> required <p>Returns:</p> Type Description <code>int</code> <p>Number of sequences</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If pyfastx is not installed</p> <code>FileNotFoundError</code> <p>If file doesn't exist</p> Source code in <code>src/votuderep/utils/io.py</code> <pre><code>def count_sequences(file_path: str) -&gt; int:\n    \"\"\"\n    Count the number of sequences in a FASTA file.\n\n    Args:\n        file_path: Path to FASTA file\n\n    Returns:\n        Number of sequences\n\n    Raises:\n        ImportError: If pyfastx is not installed\n        FileNotFoundError: If file doesn't exist\n    \"\"\"\n    if pyfastx is None:\n        raise ImportError(\n            \"pyfastx is required for reading FASTA files. \" \"Install it with: pip install pyfastx\"\n        )\n\n    path = Path(file_path)\n    if not path.exists():\n        raise FileNotFoundError(f\"FASTA file not found: {file_path}\")\n\n    count = 0\n    for _ in pyfastx.Fastx(str(path)):\n        count += 1\n    return count\n</code></pre>"},{"location":"api/#votuderep.utils.io.get_sequence_lengths","title":"<code>get_sequence_lengths(file_path)</code>","text":"<p>Get lengths of all sequences in a FASTA file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to FASTA file</p> required <p>Returns:</p> Type Description <code>dict[str, int]</code> <p>Dictionary mapping sequence IDs to their lengths</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If pyfastx is not installed</p> <code>FileNotFoundError</code> <p>If file doesn't exist</p> Source code in <code>src/votuderep/utils/io.py</code> <pre><code>def get_sequence_lengths(file_path: str) -&gt; dict[str, int]:\n    \"\"\"\n    Get lengths of all sequences in a FASTA file.\n\n    Args:\n        file_path: Path to FASTA file\n\n    Returns:\n        Dictionary mapping sequence IDs to their lengths\n\n    Raises:\n        ImportError: If pyfastx is not installed\n        FileNotFoundError: If file doesn't exist\n    \"\"\"\n    if pyfastx is None:\n        raise ImportError(\n            \"pyfastx is required for reading FASTA files. \" \"Install it with: pip install pyfastx\"\n        )\n\n    path = Path(file_path)\n    if not path.exists():\n        raise FileNotFoundError(f\"FASTA file not found: {file_path}\")\n\n    lengths = {}\n    for name, seq in pyfastx.Fastx(str(path)):\n        lengths[name] = len(seq)\n\n    return lengths\n</code></pre>"},{"location":"api/#votuderep.utils.io.filter_sequences","title":"<code>filter_sequences(file_path, sequence_ids, output_path=None, exclude=False)</code>","text":"<p>Filter sequences from a FASTA file by ID.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to input FASTA file</p> required <code>sequence_ids</code> <code>set[str]</code> <p>Set of sequence IDs to keep (or exclude)</p> required <code>output_path</code> <code>Optional[str]</code> <p>Path to output file, or None for stdout</p> <code>None</code> <code>exclude</code> <code>bool</code> <p>If True, exclude the given IDs instead of keeping them</p> <code>False</code> <p>Returns:</p> Type Description <code>int</code> <p>Number of sequences written</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If pyfastx is not installed</p> <code>FileNotFoundError</code> <p>If file doesn't exist</p> Source code in <code>src/votuderep/utils/io.py</code> <pre><code>def filter_sequences(\n    file_path: str, sequence_ids: set[str], output_path: Optional[str] = None, exclude: bool = False\n) -&gt; int:\n    \"\"\"\n    Filter sequences from a FASTA file by ID.\n\n    Args:\n        file_path: Path to input FASTA file\n        sequence_ids: Set of sequence IDs to keep (or exclude)\n        output_path: Path to output file, or None for stdout\n        exclude: If True, exclude the given IDs instead of keeping them\n\n    Returns:\n        Number of sequences written\n\n    Raises:\n        ImportError: If pyfastx is not installed\n        FileNotFoundError: If file doesn't exist\n    \"\"\"\n    count = 0\n\n    def filtered_sequences():\n        nonlocal count\n        for seq_id, seq in read_fasta(file_path):\n            should_include = (seq_id in sequence_ids) != exclude\n            if should_include:\n                count += 1\n                yield seq_id, seq\n\n    write_fasta(filtered_sequences(), output_path)\n    return count\n</code></pre>"},{"location":"api/#logging","title":"Logging","text":"<p>Logging configuration and utilities.</p>"},{"location":"api/#votuderep.utils.logging","title":"<code>votuderep.utils.logging</code>","text":"<p>Logging configuration using rich for pretty output.</p>"},{"location":"api/#votuderep.utils.logging.setup_logger","title":"<code>setup_logger(name='votuderep', level=logging.INFO, verbose=False)</code>","text":"<p>Set up a logger with rich handler.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Logger name</p> <code>'votuderep'</code> <code>level</code> <code>int</code> <p>Logging level</p> <code>INFO</code> <code>verbose</code> <code>bool</code> <p>If True, set level to DEBUG</p> <code>False</code> <p>Returns:</p> Type Description <code>Logger</code> <p>Configured logger instance</p> Source code in <code>src/votuderep/utils/logging.py</code> <pre><code>def setup_logger(\n    name: str = \"votuderep\", level: int = logging.INFO, verbose: bool = False\n) -&gt; logging.Logger:\n    \"\"\"\n    Set up a logger with rich handler.\n\n    Args:\n        name: Logger name\n        level: Logging level\n        verbose: If True, set level to DEBUG\n\n    Returns:\n        Configured logger instance\n    \"\"\"\n    # Adjust level if verbose\n    if verbose:\n        level = logging.DEBUG\n\n    # Create logger\n    logger = logging.getLogger(name)\n    logger.setLevel(level)\n\n    # Remove existing handlers to avoid duplicates\n    logger.handlers.clear()\n\n    # Create rich handler\n    handler = RichHandler(\n        console=console,\n        show_time=True,\n        show_path=False,\n        markup=True,\n        rich_tracebacks=True,\n        tracebacks_show_locals=verbose,\n    )\n    handler.setLevel(level)\n\n    # Create formatter\n    formatter = logging.Formatter(\"%(message)s\", datefmt=\"[%X]\")\n    handler.setFormatter(formatter)\n\n    # Add handler to logger\n    logger.addHandler(handler)\n\n    return logger\n</code></pre>"},{"location":"api/#votuderep.utils.logging.get_logger","title":"<code>get_logger(name=None)</code>","text":"<p>Get a logger instance.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>Logger name, defaults to 'votuderep'</p> <code>None</code> <p>Returns:</p> Type Description <code>Logger</code> <p>Logger instance</p> Source code in <code>src/votuderep/utils/logging.py</code> <pre><code>def get_logger(name: Optional[str] = None) -&gt; logging.Logger:\n    \"\"\"\n    Get a logger instance.\n\n    Args:\n        name: Logger name, defaults to 'votuderep'\n\n    Returns:\n        Logger instance\n    \"\"\"\n    if name is None:\n        name = \"votuderep\"\n    return logging.getLogger(name)\n</code></pre>"},{"location":"api/#validators","title":"Validators","text":"<p>Input validation utilities.</p>"},{"location":"api/#votuderep.utils.validators","title":"<code>votuderep.utils.validators</code>","text":"<p>Validation utilities for checking external tools and file existence.</p>"},{"location":"api/#votuderep.utils.validators.VotuDerepError","title":"<code>VotuDerepError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for votuderep errors.</p> Source code in <code>src/votuderep/utils/validators.py</code> <pre><code>class VotuDerepError(Exception):\n    \"\"\"Base exception for votuderep errors.\"\"\"\n\n    pass\n</code></pre>"},{"location":"api/#votuderep.utils.validators.BlastnNotFoundError","title":"<code>BlastnNotFoundError</code>","text":"<p>               Bases: <code>VotuDerepError</code></p> <p>Exception raised when blastn is not found in PATH.</p> Source code in <code>src/votuderep/utils/validators.py</code> <pre><code>class BlastnNotFoundError(VotuDerepError):\n    \"\"\"Exception raised when blastn is not found in PATH.\"\"\"\n\n    pass\n</code></pre>"},{"location":"api/#votuderep.utils.validators.FileValidationError","title":"<code>FileValidationError</code>","text":"<p>               Bases: <code>VotuDerepError</code></p> <p>Exception raised when file validation fails.</p> Source code in <code>src/votuderep/utils/validators.py</code> <pre><code>class FileValidationError(VotuDerepError):\n    \"\"\"Exception raised when file validation fails.\"\"\"\n\n    pass\n</code></pre>"},{"location":"api/#votuderep.utils.validators.check_blastn","title":"<code>check_blastn(custom_path=None)</code>","text":"<p>Check if blastn is available in PATH or at custom location.</p> <p>Parameters:</p> Name Type Description Default <code>custom_path</code> <code>Optional[str]</code> <p>Optional custom path to blastn executable</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Path to blastn executable</p> <p>Raises:</p> Type Description <code>BlastnNotFoundError</code> <p>If blastn is not found</p> Source code in <code>src/votuderep/utils/validators.py</code> <pre><code>def check_blastn(custom_path: Optional[str] = None) -&gt; str:\n    \"\"\"\n    Check if blastn is available in PATH or at custom location.\n\n    Args:\n        custom_path: Optional custom path to blastn executable\n\n    Returns:\n        Path to blastn executable\n\n    Raises:\n        BlastnNotFoundError: If blastn is not found\n    \"\"\"\n    # Check custom path first\n    if custom_path:\n        if os.path.isfile(custom_path) and os.access(custom_path, os.X_OK):\n            return custom_path\n        raise BlastnNotFoundError(f\"blastn not found at specified path: {custom_path}\")\n\n    # Check environment variable\n    env_path = os.environ.get(\"VOTUDEREP_BLASTN_PATH\")\n    if env_path:\n        if os.path.isfile(env_path) and os.access(env_path, os.X_OK):\n            return env_path\n        raise BlastnNotFoundError(f\"blastn not found at VOTUDEREP_BLASTN_PATH: {env_path}\")\n\n    # Check PATH\n    blastn_path = shutil.which(\"blastn\")\n    if blastn_path:\n        return blastn_path\n\n    # Not found anywhere\n    raise BlastnNotFoundError(\n        \"blastn not found in PATH. Please install BLAST+ toolkit.\\n\"\n        \"Installation instructions:\\n\"\n        \"  - Conda: conda install -c bioconda blast\\n\"\n        \"  - Ubuntu/Debian: apt-get install ncbi-blast+\\n\"\n        \"  - MacOS: brew install blast\\n\"\n        \"  - Or download from: https://blast.ncbi.nlm.nih.gov/Blast.cgi?PAGE_TYPE=BlastDocs&amp;DOC_TYPE=Download\\n\"\n        \"Alternatively, set VOTUDEREP_BLASTN_PATH environment variable.\"\n    )\n</code></pre>"},{"location":"api/#votuderep.utils.validators.get_blastn_version","title":"<code>get_blastn_version(blastn_path)</code>","text":"<p>Get blastn version string.</p> <p>Parameters:</p> Name Type Description Default <code>blastn_path</code> <code>str</code> <p>Path to blastn executable</p> required <p>Returns:</p> Type Description <code>str</code> <p>Version string</p> <p>Raises:</p> Type Description <code>VotuDerepError</code> <p>If version check fails</p> Source code in <code>src/votuderep/utils/validators.py</code> <pre><code>def get_blastn_version(blastn_path: str) -&gt; str:\n    \"\"\"\n    Get blastn version string.\n\n    Args:\n        blastn_path: Path to blastn executable\n\n    Returns:\n        Version string\n\n    Raises:\n        VotuDerepError: If version check fails\n    \"\"\"\n    try:\n        result = subprocess.run(\n            [blastn_path, \"-version\"], capture_output=True, text=True, check=True\n        )\n        # Extract version from output (e.g., \"blastn: 2.13.0+\")\n        version_line = result.stdout.strip().split(\"\\n\")[0]\n        return version_line\n    except subprocess.CalledProcessError as e:\n        raise VotuDerepError(f\"Failed to get blastn version: {e}\")\n</code></pre>"},{"location":"api/#votuderep.utils.validators.validate_file_exists","title":"<code>validate_file_exists(file_path, file_type='file')</code>","text":"<p>Validate that a file exists and is readable.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to file</p> required <code>file_type</code> <code>str</code> <p>Type of file for error message (e.g., \"input FASTA\")</p> <code>'file'</code> <p>Returns:</p> Type Description <code>Path</code> <p>Path object for the validated file</p> <p>Raises:</p> Type Description <code>FileValidationError</code> <p>If file doesn't exist or isn't readable</p> Source code in <code>src/votuderep/utils/validators.py</code> <pre><code>def validate_file_exists(file_path: str, file_type: str = \"file\") -&gt; Path:\n    \"\"\"\n    Validate that a file exists and is readable.\n\n    Args:\n        file_path: Path to file\n        file_type: Type of file for error message (e.g., \"input FASTA\")\n\n    Returns:\n        Path object for the validated file\n\n    Raises:\n        FileValidationError: If file doesn't exist or isn't readable\n    \"\"\"\n    path = Path(file_path)\n\n    if not path.exists():\n        raise FileValidationError(f\"{file_type} not found: {file_path}\")\n\n    if not path.is_file():\n        raise FileValidationError(f\"{file_type} is not a file: {file_path}\")\n\n    if not os.access(path, os.R_OK):\n        raise FileValidationError(f\"{file_type} is not readable: {file_path}\")\n\n    return path\n</code></pre>"},{"location":"api/#votuderep.utils.validators.validate_output_path","title":"<code>validate_output_path(file_path)</code>","text":"<p>Validate that output path is writable.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to output file</p> required <p>Returns:</p> Type Description <code>Path</code> <p>Path object for the output file</p> <p>Raises:</p> Type Description <code>FileValidationError</code> <p>If output directory doesn't exist or isn't writable</p> Source code in <code>src/votuderep/utils/validators.py</code> <pre><code>def validate_output_path(file_path: str) -&gt; Path:\n    \"\"\"\n    Validate that output path is writable.\n\n    Args:\n        file_path: Path to output file\n\n    Returns:\n        Path object for the output file\n\n    Raises:\n        FileValidationError: If output directory doesn't exist or isn't writable\n    \"\"\"\n    path = Path(file_path)\n\n    # Check if parent directory exists and is writable\n    parent = path.parent\n    if not parent.exists():\n        raise FileValidationError(f\"Output directory does not exist: {parent}\")\n\n    if not os.access(parent, os.W_OK):\n        raise FileValidationError(f\"Output directory is not writable: {parent}\")\n\n    # If file exists, check if it's writable\n    if path.exists() and not os.access(path, os.W_OK):\n        raise FileValidationError(f\"Output file exists but is not writable: {file_path}\")\n\n    return path\n</code></pre>"},{"location":"api/#votuderep.utils.validators.validate_percentage","title":"<code>validate_percentage(value, name, min_val=0.0, max_val=100.0)</code>","text":"<p>Validate that a value is a valid percentage.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>Value to validate</p> required <code>name</code> <code>str</code> <p>Name of parameter for error message</p> required <code>min_val</code> <code>float</code> <p>Minimum allowed value</p> <code>0.0</code> <code>max_val</code> <code>float</code> <p>Maximum allowed value</p> <code>100.0</code> <p>Returns:</p> Type Description <code>float</code> <p>The validated value</p> <p>Raises:</p> Type Description <code>VotuDerepError</code> <p>If value is out of range</p> Source code in <code>src/votuderep/utils/validators.py</code> <pre><code>def validate_percentage(\n    value: float, name: str, min_val: float = 0.0, max_val: float = 100.0\n) -&gt; float:\n    \"\"\"\n    Validate that a value is a valid percentage.\n\n    Args:\n        value: Value to validate\n        name: Name of parameter for error message\n        min_val: Minimum allowed value\n        max_val: Maximum allowed value\n\n    Returns:\n        The validated value\n\n    Raises:\n        VotuDerepError: If value is out of range\n    \"\"\"\n    if not min_val &lt;= value &lt;= max_val:\n        raise VotuDerepError(f\"{name} must be between {min_val} and {max_val}, got {value}\")\n    return value\n</code></pre>"},{"location":"api/#command-modules","title":"Command Modules","text":""},{"location":"api/#derep-command","title":"Derep Command","text":""},{"location":"api/#votuderep.commands.derep","title":"<code>votuderep.commands.derep</code>","text":"<p>Derep command for dereplicating vOTUs.</p>"},{"location":"api/#votuderep.commands.derep.derep","title":"<code>derep(ctx, input, output, threads, tmp, min_ani, min_tcov, keep)</code>","text":"<p>Dereplicate vOTUs using BLAST and ANI clustering.</p> <p>This command: 1. Creates a BLAST database from input sequences 2. Performs all-vs-all BLAST comparison 3. Calculates ANI and coverage for sequence pairs 4. Clusters sequences by ANI using greedy algorithm 5. Outputs cluster representatives (longest sequences)</p> <p>The algorithm selects the longest sequence from each cluster as the representative, effectively removing shorter redundant sequences.</p>"},{"location":"api/#filter-command","title":"Filter Command","text":""},{"location":"api/#votuderep.commands.filter","title":"<code>votuderep.commands.filter</code>","text":"<p>Filter command for filtering FASTA files using CheckV metrics.</p>"},{"location":"api/#getdbs-command","title":"GetDBs Command","text":""},{"location":"api/#votuderep.commands.getdbs","title":"<code>votuderep.commands.getdbs</code>","text":"<p>Getdbs command for downloading genomad and checkv databases.</p>"},{"location":"api/#votuderep.commands.getdbs.getdbs","title":"<code>getdbs(ctx, outdir, force, db)</code>","text":"<p>Download geNomad, CheckV, and PHROGs databases.</p> <p>Downloads and extracts viral classification and quality control databases required for viral metagenomics analysis.</p> <p>The command is resumable: if interrupted, it will skip already downloaded and extracted files when re-run.</p> <p>\b Available databases:   genomad_1.9  - geNomad viral identification database   checkv_1.5   - CheckV viral quality control database   phrogs_4     - PHROGs viral protein families database   all          - Download all databases (default)</p> <p>\b Examples:   votuderep getdbs --outdir ~/databases   votuderep getdbs -o ./db --db genomad_1.9 --db checkv_1.5   votuderep getdbs -o ./db --db genomad_1.9,checkv_1.5   votuderep getdbs -o ./db --db all</p>"},{"location":"api/#tabulate-command","title":"Tabulate Command","text":""},{"location":"api/#votuderep.commands.tabulate","title":"<code>votuderep.commands.tabulate</code>","text":"<p>Tabulate command for generating CSV files from reads directories.</p>"},{"location":"api/#votuderep.commands.tabulate.tabulate","title":"<code>tabulate(ctx, input_dir, output, delimiter, for_tag, rev_tag, strip_strings, extension, absolute)</code>","text":"<p>Generate CSV file from a directory containing sequencing reads.</p> <p>Scans INPUT_DIR for paired-end sequencing reads and generates a CSV table mapping sample names to their R1 and R2 file paths.</p> <p>The command identifies read pairs by looking for forward/reverse tags in filenames, extracts sample names, and outputs a table suitable for downstream analysis tools.</p> <p>\b Example:   votuderep tabulate reads/ -o samples.csv   votuderep tabulate reads/ --for-tag 1 --rev-tag _2 --extension .fq.gz   votuderep tabulate reads/ --strip \"Sample\" --strip \".filtered\" -a</p>"},{"location":"api/#trainingdata-command","title":"TrainingData Command","text":""},{"location":"api/#votuderep.commands.trainingdata","title":"<code>votuderep.commands.trainingdata</code>","text":"<p>Trainingdata command for downloading training datasets.</p>"},{"location":"api/#votuderep.commands.trainingdata.trainingdata","title":"<code>trainingdata(ctx, outdir, dataset_name)</code>","text":"<p>Download training dataset from the internet.</p> <p>Uses a registry (DATASETS) of named datasets, each containing a set of {url, path} items. Adds new datasets by extending the DATASETS dict.</p>"},{"location":"api/#splitcoverm-command","title":"SplitCoverM Command","text":""},{"location":"api/#votuderep.commands.splitcoverm","title":"<code>votuderep.commands.splitcoverm</code>","text":"<p>Split CoverM command for splitting CoverM TSV by metrics.</p>"},{"location":"api/#votuderep.commands.splitcoverm.splitcoverm","title":"<code>splitcoverm(ctx, input_file, basename)</code>","text":"<p>Split a CoverM TSV by metric into separate TSVs, one per metric.</p> <p>Reads a CoverM output table containing multiple metrics across samples and splits it into individual TSV files, one for each metric. Each output file will have the format: _.tsv <p>The input TSV is expected to have columns formatted as: \"Contig\", \" \", \" \", ... <p>\b Example:   votuderep splitcoverm -i coverage.tsv -o output/cov   votuderep splitcoverm -i coverage.tsv.gz -o results/sample</p>"},{"location":"api/#programmatic-usage","title":"Programmatic Usage","text":"<p>You can use votuderep functionality in your own Python scripts:</p>"},{"location":"api/#example-dereplication","title":"Example: Dereplication","text":"<pre><code>from votuderep.core.dereplication import dereplicate_sequences\nfrom votuderep.core.blast import run_blast\n\n# Read your sequences\nsequences = {...}  # Your sequence dictionary\n\n# Run BLAST comparison\nblast_results = run_blast(\n    sequences,\n    threads=4,\n    min_identity=95.0\n)\n\n# Perform clustering\nrepresentatives = dereplicate_sequences(\n    sequences,\n    blast_results,\n    min_ani=95.0,\n    min_coverage=85.0\n)\n</code></pre>"},{"location":"api/#example-filtering","title":"Example: Filtering","text":"<pre><code>from votuderep.core.filtering import filter_by_checkv\nimport pandas as pd\n\n# Load CheckV results\ncheckv_df = pd.read_csv(\"checkv_output.tsv\", sep=\"\\t\")\n\n# Filter sequences\nfiltered_ids = filter_by_checkv(\n    checkv_df,\n    min_quality=\"medium\",\n    min_completeness=50.0,\n    min_length=5000\n)\n\n# Use filtered IDs to select sequences\n</code></pre>"},{"location":"api/#example-io-operations","title":"Example: I/O Operations","text":"<pre><code>from votuderep.utils.io import read_fasta, write_fasta\n\n# Read sequences\nsequences = read_fasta(\"input.fasta\")\n\n# Process sequences\n# ... your processing code ...\n\n# Write results\nwrite_fasta(filtered_sequences, \"output.fasta\")\n</code></pre>"},{"location":"api/#type-hints","title":"Type Hints","text":"<p>All modules include type hints for better IDE support and type checking:</p> <pre><code>from typing import Dict, List, Tuple\nfrom votuderep.core.dereplication import dereplicate_sequences\n\ndef my_function(sequences: Dict[str, str]) -&gt; List[str]:\n    \"\"\"My custom function using votuderep.\"\"\"\n    # Type hints provide autocomplete and error checking\n    representatives = dereplicate_sequences(sequences, ...)\n    return list(representatives.keys())\n</code></pre>"},{"location":"api/#error-handling","title":"Error Handling","text":"<p>The package defines custom exceptions for better error handling:</p> <pre><code>from votuderep.utils.validators import ValidationError\n\ntry:\n    # Your code here\n    process_sequences(input_file)\nexcept ValidationError as e:\n    print(f\"Validation failed: {e}\")\nexcept FileNotFoundError as e:\n    print(f\"File not found: {e}\")\n</code></pre>"},{"location":"api/#see-also","title":"See Also","text":"<ul> <li>CLI Commands - Command-line interface documentation</li> <li>Quick Start Guide - Getting started with votuderep</li> <li>GitHub Repository - Source code</li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#requirements","title":"Requirements","text":"<ul> <li>Python &gt;= 3.10</li> <li>BLAST+ toolkit (specifically <code>blastn</code> and <code>makeblastdb</code>)</li> </ul>"},{"location":"installation/#installing-votuderep","title":"Installing votuderep","text":""},{"location":"installation/#from-pypi-recommended","title":"From PyPI (Recommended)","text":"<pre><code>pip install votuderep\n</code></pre>"},{"location":"installation/#from-condabioconda","title":"From Conda/Bioconda","text":"<pre><code>conda install -c bioconda votuderep\n</code></pre>"},{"location":"installation/#from-source","title":"From Source","text":"<pre><code># Clone the repository\ngit clone https://github.com/quadram-institute-bioscience/votuderep.git\ncd votuderep\n\n# Install in development mode\npip install -e .\n\n# Or install normally\npip install .\n</code></pre>"},{"location":"installation/#installing-blast","title":"Installing BLAST+","text":"<p>votuderep requires BLAST+ to be installed and available in your PATH for the <code>derep</code> command:</p>"},{"location":"installation/#using-conda-recommended","title":"Using conda (recommended)","text":"<pre><code>conda install -c bioconda blast\n</code></pre>"},{"location":"installation/#on-ubuntudebian","title":"On Ubuntu/Debian","text":"<pre><code>sudo apt-get install ncbi-blast+\n</code></pre>"},{"location":"installation/#on-macos","title":"On macOS","text":"<pre><code>brew install blast\n</code></pre>"},{"location":"installation/#verify-installation","title":"Verify Installation","text":"<p>After installation, verify that BLAST+ is available:</p> <pre><code>blastn -version\nmakeblastdb -version\n</code></pre>"},{"location":"installation/#optional-dependencies","title":"Optional Dependencies","text":""},{"location":"installation/#development-dependencies","title":"Development Dependencies","text":"<p>If you're contributing to the project or want to run tests:</p> <pre><code>pip install -e \".[dev]\"\n</code></pre> <p>This includes: - pytest - pytest-cov - black (code formatter) - ruff (linter)</p>"},{"location":"installation/#documentation-dependencies","title":"Documentation Dependencies","text":"<p>To build the documentation locally:</p> <pre><code>pip install -e \".[docs]\"\n</code></pre> <p>This includes: - mkdocs - mkdocs-material - mkdocstrings - mkdocs-click</p>"},{"location":"installation/#verifying-installation","title":"Verifying Installation","text":"<p>After installation, verify that votuderep is available:</p> <pre><code>votuderep --version\nvotuderep --help\n</code></pre> <p>You should see the version information and available commands.</p>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"installation/#command-not-found","title":"Command not found","text":"<p>If you get a \"command not found\" error after installation:</p> <ol> <li>Make sure your Python scripts directory is in your PATH</li> <li>Try using <code>python -m votuderep</code> instead of <code>votuderep</code></li> <li>If installed with <code>--user</code>, add <code>~/.local/bin</code> to your PATH</li> </ol>"},{"location":"installation/#blast-not-found","title":"BLAST+ not found","text":"<p>If votuderep can't find BLAST+ tools:</p> <ol> <li>Verify BLAST+ is installed: <code>which blastn</code></li> <li>Ensure your PATH includes the BLAST+ installation directory</li> <li>Consider using conda to install BLAST+ in the same environment</li> </ol>"},{"location":"installation/#next-steps","title":"Next Steps","text":"<p>Once installation is complete, check out the Quick Start Guide to start using votuderep.</p>"},{"location":"quickstart/","title":"Quick Start Guide","text":"<p>This guide will walk you through the most common workflows with votuderep.</p>"},{"location":"quickstart/#basic-workflow","title":"Basic Workflow","text":"<p>The typical workflow for processing viral contigs involves:</p> <ol> <li>Download databases (one-time setup)</li> <li>Filter viral contigs by quality (using CheckV output)</li> <li>Dereplicate to remove redundant sequences</li> </ol>"},{"location":"quickstart/#1-download-databases","title":"1. Download Databases","text":"<p>First, download the required databases for viral annotation tools:</p> <pre><code># Download all databases (geNomad, CheckV, PHROGs)\nvotuderep getdbs -o ./databases/\n\n# Or download specific databases\nvotuderep getdbs -o ./databases/ --db genomad_1.9\nvotuderep getdbs -o ./databases/ --db checkv_1.5\n</code></pre> <p>Note</p> <p>This is a one-time setup. The databases can be reused for multiple analyses.</p>"},{"location":"quickstart/#2-filter-viral-contigs","title":"2. Filter Viral Contigs","text":"<p>After running CheckV on your viral contigs, filter them based on quality metrics:</p> <pre><code># Basic filtering - keep sequences with minimum quality\nvotuderep filter viral_contigs.fasta checkv_output.tsv -o filtered.fasta\n\n# High-quality sequences only\nvotuderep filter viral_contigs.fasta checkv_output.tsv \\\n  --min-quality high -o high_quality.fasta\n\n# Complete genomes with minimum length\nvotuderep filter viral_contigs.fasta checkv_output.tsv \\\n  --complete --min-len 5000 -o complete_genomes.fasta\n</code></pre>"},{"location":"quickstart/#3-dereplicate-sequences","title":"3. Dereplicate Sequences","text":"<p>Remove redundant sequences using BLAST-based ANI clustering:</p> <pre><code># Basic dereplication (95% ANI, 85% coverage)\nvotuderep derep -i filtered.fasta -o dereplicated.fasta\n\n# Custom parameters with more threads\nvotuderep derep -i filtered.fasta -o dereplicated.fasta \\\n  --min-ani 97 --min-tcov 90 -t 8\n</code></pre>"},{"location":"quickstart/#complete-example","title":"Complete Example","text":"<p>Here's a complete workflow from start to finish:</p> <pre><code># Step 1: Download databases (one-time)\nvotuderep getdbs -o ./databases/ --db checkv_1.5\n\n# Step 2: Run CheckV on your viral contigs (external tool)\n# checkv end_to_end viral_contigs.fasta checkv_out/ -d ./databases/checkv-db-v1.5\n\n# Step 3: Filter based on CheckV quality\nvotuderep filter viral_contigs.fasta checkv_out/quality_summary.tsv \\\n  --min-quality medium \\\n  --min-completeness 50 \\\n  --min-len 3000 \\\n  -o filtered_contigs.fasta\n\n# Step 4: Dereplicate the filtered sequences\nvotuderep derep -i filtered_contigs.fasta \\\n  -o final_vOTUs.fasta \\\n  --min-ani 95 \\\n  --min-tcov 85 \\\n  -t 8\n</code></pre>"},{"location":"quickstart/#working-with-sequencing-reads","title":"Working with Sequencing Reads","text":"<p>If you need to create a sample table for Nextflow pipelines:</p> <pre><code># Generate CSV from paired-end reads directory\nvotuderep tabulate reads/ -o samples.csv\n\n# With custom read tags\nvotuderep tabulate reads/ \\\n  --for-tag _1.fastq.gz \\\n  --rev-tag _2.fastq.gz \\\n  -o samples.csv\n</code></pre>"},{"location":"quickstart/#getting-help","title":"Getting Help","text":"<p>Every command has detailed help available:</p> <pre><code># General help\nvotuderep --help\n\n# Command-specific help\nvotuderep derep --help\nvotuderep filter --help\nvotuderep getdbs --help\n</code></pre>"},{"location":"quickstart/#common-parameters","title":"Common Parameters","text":""},{"location":"quickstart/#ani-and-coverage-thresholds","title":"ANI and Coverage Thresholds","text":"<p>For the <code>derep</code> command:</p> <ul> <li><code>--min-ani</code>: Average Nucleotide Identity threshold (0-100)<ul> <li>Default: 95.0</li> <li>Higher = stricter (fewer clusters)</li> <li>Common values: 95-99</li> </ul> </li> <li><code>--min-tcov</code>: Minimum target coverage (0-100)<ul> <li>Default: 85.0</li> <li>Percentage of the sequence that must be covered</li> </ul> </li> </ul>"},{"location":"quickstart/#quality-filtering","title":"Quality Filtering","text":"<p>For the <code>filter</code> command:</p> <ul> <li><code>--min-quality</code>: Minimum CheckV quality level<ul> <li><code>low</code>: Includes all quality levels (default)</li> <li><code>medium</code>: Includes Medium, High, and Complete</li> <li><code>high</code>: Includes only High and Complete</li> </ul> </li> <li><code>--min-completeness</code>: Minimum genome completeness (0-100)</li> <li><code>--max-contam</code>: Maximum contamination percentage</li> </ul>"},{"location":"quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Explore individual CLI Commands for detailed options</li> <li>Read the API Reference for programmatic usage</li> <li>Check out the training data: <code>votuderep trainingdata</code></li> </ul>"},{"location":"cli/","title":"CLI Commands Overview","text":"<p>votuderep provides a comprehensive set of command-line tools for working with viral sequences (vOTUs).</p>"},{"location":"cli/#available-commands","title":"Available Commands","text":""},{"location":"cli/#core-commands","title":"Core Commands","text":""},{"location":"cli/#derep","title":"derep","text":"<p>Remove redundant viral sequences using BLAST-based ANI clustering. This is the main dereplication command that uses average nucleotide identity (ANI) and coverage thresholds to identify and remove similar sequences.</p> <p>Quick Example: <pre><code>votuderep derep -i input.fasta -o dereplicated.fasta --min-ani 95 --min-tcov 85\n</code></pre></p>"},{"location":"cli/#filter","title":"filter","text":"<p>Filter viral contigs based on CheckV quality metrics. Use this command after running CheckV to select sequences based on quality, completeness, contamination, and other criteria.</p> <p>Quick Example: <pre><code>votuderep filter contigs.fasta checkv_output.tsv --min-quality high -o filtered.fasta\n</code></pre></p>"},{"location":"cli/#database-management","title":"Database Management","text":""},{"location":"cli/#getdbs","title":"getdbs","text":"<p>Download geNomad, CheckV, and PHROGs databases. This command simplifies database management by automatically downloading and setting up the required reference databases.</p> <p>Quick Example: <pre><code>votuderep getdbs -o ./databases/ --db all\n</code></pre></p>"},{"location":"cli/#utility-commands","title":"Utility Commands","text":""},{"location":"cli/#tabulate","title":"tabulate","text":"<p>Generate CSV tables from paired-end sequencing read directories. Useful for creating sample sheets for workflow managers like Nextflow.</p> <p>Quick Example: <pre><code>votuderep tabulate reads/ -o samples.csv\n</code></pre></p>"},{"location":"cli/#trainingdata","title":"trainingdata","text":"<p>Download viral assembly and sequencing read datasets for training and testing purposes. Includes datasets from the EBAME workshop.</p> <p>Quick Example: <pre><code>votuderep trainingdata -o ./ebame-virome/\n</code></pre></p>"},{"location":"cli/#splitcoverm","title":"splitcoverm","text":"<p>Split CoverM TSV output by metric into separate files. Each metric (coverage, mean, etc.) gets its own TSV file for easier downstream analysis.</p> <p>Quick Example: <pre><code>votuderep splitcoverm -i coverage.tsv -o output/prefix\n</code></pre></p>"},{"location":"cli/#global-options","title":"Global Options","text":"<p>All commands support these global options:</p> Option Description <code>-h, --help</code> Show help message and exit <code>--version</code> Show program version and exit <code>-v, --verbose</code> Enable verbose logging output"},{"location":"cli/#command-structure","title":"Command Structure","text":"<p>All votuderep commands follow this general structure:</p> <pre><code>votuderep [GLOBAL_OPTIONS] &lt;command&gt; [COMMAND_OPTIONS] [ARGUMENTS]\n</code></pre> <p>Example: <pre><code>votuderep -v derep -i input.fasta -o output.fasta --min-ani 97 -t 8\n         \u2502    \u2502                                               \u2502\n         \u2502    \u2514\u2500 command                                      \u2514\u2500 command options\n         \u2514\u2500 global option\n</code></pre></p>"},{"location":"cli/#getting-help","title":"Getting Help","text":"<p>Get detailed help for any command:</p> <pre><code># General help\nvotuderep --help\n\n# Command-specific help\nvotuderep derep --help\nvotuderep filter --help\n</code></pre>"},{"location":"cli/#common-workflows","title":"Common Workflows","text":""},{"location":"cli/#basic-viral-contig-processing","title":"Basic Viral Contig Processing","text":"<ol> <li> <p>Filter quality sequences: <pre><code>votuderep filter contigs.fasta checkv_out/quality_summary.tsv \\\n  --min-quality medium -o filtered.fasta\n</code></pre></p> </li> <li> <p>Dereplicate: <pre><code>votuderep derep -i filtered.fasta -o final_vOTUs.fasta\n</code></pre></p> </li> </ol>"},{"location":"cli/#database-setup","title":"Database Setup","text":"<pre><code># Download all databases\nvotuderep getdbs -o ./databases/\n\n# Or download specific databases\nvotuderep getdbs -o ./databases/ --db checkv_1.5\nvotuderep getdbs -o ./databases/ --db genomad_1.9\n</code></pre>"},{"location":"cli/#preparing-sample-sheets","title":"Preparing Sample Sheets","text":"<pre><code># Create sample sheet from reads directory\nvotuderep tabulate reads/ -o samples.csv --for-tag _R1 --rev-tag _R2\n</code></pre>"},{"location":"cli/#next-steps","title":"Next Steps","text":"<p>Click on any command above to see its detailed documentation with all available options and usage examples.</p>"},{"location":"cli/derep/","title":"votuderep derep","text":"<p>Remove redundant viral sequences using BLAST-based ANI (Average Nucleotide Identity) clustering.</p>"},{"location":"cli/derep/#overview","title":"Overview","text":"<p>The <code>derep</code> command performs dereplication of viral sequences by:</p> <ol> <li>Running all-vs-all BLAST comparison</li> <li>Calculating ANI and alignment coverage for each pair</li> <li>Clustering sequences based on ANI and coverage thresholds</li> <li>Selecting representative sequences from each cluster</li> </ol> <p>This is useful for reducing redundancy in viral contig datasets while maintaining diversity.</p>"},{"location":"cli/derep/#usage","title":"Usage","text":"<pre><code>votuderep derep [OPTIONS]\n</code></pre>"},{"location":"cli/derep/#required-options","title":"Required Options","text":"<ul> <li><code>-i, --input PATH</code> - Input FASTA file containing vOTUs</li> </ul>"},{"location":"cli/derep/#options","title":"Options","text":"<ul> <li><code>-o, --output PATH</code> - Output FASTA file with dereplicated vOTUs (default: dereplicated_vOTUs.fasta)</li> <li><code>-t, --threads INTEGER</code> - Number of threads for BLAST (default: 2)</li> <li><code>--tmp TEXT</code> - Directory for temporary files (default: $TEMP or /tmp or ./)</li> <li><code>--min-ani FLOAT</code> - Minimum ANI to consider two vOTUs as the same (default: 95.0)</li> <li><code>--min-tcov FLOAT</code> - Minimum target coverage to consider two vOTUs as the same (default: 85.0)</li> <li><code>--keep</code> - Keep the temporary directory after completion</li> </ul>"},{"location":"cli/derep/#examples","title":"Examples","text":""},{"location":"cli/derep/#basic-dereplication","title":"Basic Dereplication","text":"<p>Use default thresholds (95% ANI, 85% coverage):</p> <pre><code>votuderep derep -i viral_contigs.fasta -o dereplicated.fasta\n</code></pre>"},{"location":"cli/derep/#custom-parameters","title":"Custom Parameters","text":"<p>Adjust ANI and coverage thresholds:</p> <pre><code>votuderep derep -i viral_contigs.fasta -o dereplicated.fasta \\\n  --min-ani 97 \\\n  --min-tcov 90 \\\n  -t 8\n</code></pre>"},{"location":"cli/derep/#keep-intermediate-files","title":"Keep Intermediate Files","text":"<p>Useful for debugging or inspecting BLAST results:</p> <pre><code>votuderep derep -i viral_contigs.fasta -o dereplicated.fasta \\\n  --keep \\\n  --tmp ./temp_derep\n</code></pre> <p>This will preserve: - BLAST database files - BLAST output - Intermediate clustering files</p>"},{"location":"cli/derep/#large-datasets","title":"Large Datasets","text":"<p>For large datasets, increase threads and use a dedicated temporary directory:</p> <pre><code>votuderep derep -i large_dataset.fasta -o dereplicated.fasta \\\n  --min-ani 95 \\\n  --min-tcov 85 \\\n  -t 16 \\\n  --tmp /scratch/temp_blast\n</code></pre>"},{"location":"cli/derep/#parameters-explained","title":"Parameters Explained","text":""},{"location":"cli/derep/#ani-threshold-min-ani","title":"ANI Threshold (<code>--min-ani</code>)","text":"<p>Average Nucleotide Identity measures sequence similarity:</p> <ul> <li>95% (default): Standard for species-level clustering of viruses</li> <li>97-99%: Stricter, for strain-level distinction</li> <li>90-94%: More permissive, groups more diverse sequences</li> </ul>"},{"location":"cli/derep/#coverage-threshold-min-tcov","title":"Coverage Threshold (<code>--min-tcov</code>)","text":"<p>Target coverage measures what percentage of the shorter sequence is covered by the alignment:</p> <ul> <li>85% (default): Balanced approach</li> <li>90-95%: More stringent, requires longer alignments</li> <li>70-80%: More permissive, allows partial matches</li> </ul> <p>Choosing Thresholds</p> <ul> <li>For species-level vOTUs: <code>--min-ani 95 --min-tcov 85</code></li> <li>For strain-level vOTUs: <code>--min-ani 97 --min-tcov 90</code></li> <li>For genus-level grouping: <code>--min-ani 90 --min-tcov 80</code></li> </ul>"},{"location":"cli/derep/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Threads: Use <code>-t</code> to match your CPU cores for faster BLAST</li> <li>Temporary Directory: Use <code>--tmp</code> to specify a fast storage location (SSD or RAM disk)</li> <li>Memory: Large datasets may require substantial RAM for BLAST operations</li> </ul>"},{"location":"cli/derep/#output","title":"Output","text":"<p>The output FASTA file contains representative sequences from each cluster. The selection criteria:</p> <ol> <li>Longest sequence in the cluster (by default)</li> <li>If tied, the one with the most connections</li> <li>If still tied, alphabetically first sequence ID</li> </ol>"},{"location":"cli/derep/#requirements","title":"Requirements","text":"<p>This command requires:</p> <ul> <li>BLAST+ toolkit (<code>blastn</code> and <code>makeblastdb</code>)</li> <li>Sufficient disk space in temporary directory for BLAST database and results</li> </ul>"},{"location":"cli/derep/#see-also","title":"See Also","text":"<ul> <li>filter - Filter sequences before dereplication</li> <li>Quick Start Guide - Complete workflow examples</li> </ul>"},{"location":"cli/filter/","title":"votuderep filter","text":"<p>Filter viral contigs based on CheckV quality metrics.</p>"},{"location":"cli/filter/#overview","title":"Overview","text":"<p>The <code>filter</code> command processes viral contigs using quality assessment results from CheckV. It allows you to select sequences based on multiple criteria including quality level, completeness, contamination, length, and more.</p>"},{"location":"cli/filter/#usage","title":"Usage","text":"<pre><code>votuderep filter [OPTIONS] FASTA CHECKV_OUT\n</code></pre>"},{"location":"cli/filter/#required-arguments","title":"Required Arguments","text":"<ul> <li><code>FASTA</code> - Input FASTA file with viral contigs</li> <li><code>CHECKV_OUT</code> - TSV output file from CheckV (quality_summary.tsv)</li> </ul>"},{"location":"cli/filter/#options","title":"Options","text":"<p>Output: - <code>-o, --output FILE</code> - Output FASTA file (default: STDOUT)</p> <p>Length Filters: - <code>-m, --min-len INTEGER</code> - Minimum contig length - <code>--max-len INTEGER</code> - Maximum contig length (0 = unlimited)</p> <p>Quality Filters: - <code>--min-quality [low|medium|high]</code> - Minimum quality level (default: low) - <code>--complete</code> - Only keep complete genomes - <code>--exclude-undetermined</code> - Exclude contigs with quality \"Not-determined\"</p> <p>Metrics Filters: - <code>-c, --min-completeness FLOAT</code> - Minimum completeness percentage - <code>--max-contam FLOAT</code> - Maximum contamination percentage - <code>--no-warnings</code> - Only keep contigs with no warnings</p> <p>Other: - <code>--provirus</code> - Only select proviruses</p>"},{"location":"cli/filter/#examples","title":"Examples","text":""},{"location":"cli/filter/#basic-quality-filtering","title":"Basic Quality Filtering","text":"<p>Keep only sequences with at least \"low\" quality (default):</p> <pre><code>votuderep filter viral_contigs.fasta checkv_output.tsv -o filtered.fasta\n</code></pre>"},{"location":"cli/filter/#high-quality-sequences","title":"High-Quality Sequences","text":"<p>Keep only high-quality and complete sequences:</p> <pre><code>votuderep filter viral_contigs.fasta checkv_output.tsv \\\n  --min-quality high \\\n  -o high_quality.fasta\n</code></pre>"},{"location":"cli/filter/#complete-genomes-only","title":"Complete Genomes Only","text":"<p>Select only complete viral genomes:</p> <pre><code>votuderep filter viral_contigs.fasta checkv_output.tsv \\\n  --complete \\\n  -o complete_genomes.fasta\n</code></pre>"},{"location":"cli/filter/#length-filtering","title":"Length Filtering","text":"<p>Filter by minimum and maximum length:</p> <pre><code>votuderep filter viral_contigs.fasta checkv_output.tsv \\\n  --min-len 5000 \\\n  --max-len 200000 \\\n  -o size_filtered.fasta\n</code></pre>"},{"location":"cli/filter/#complex-filtering","title":"Complex Filtering","text":"<p>Combine multiple criteria:</p> <pre><code>votuderep filter viral_contigs.fasta checkv_output.tsv \\\n  --min-quality medium \\\n  --min-completeness 80 \\\n  --max-contam 5 \\\n  --no-warnings \\\n  --min-len 3000 \\\n  --exclude-undetermined \\\n  -o high_confidence.fasta\n</code></pre>"},{"location":"cli/filter/#provirus-selection","title":"Provirus Selection","text":"<p>Select only proviruses:</p> <pre><code>votuderep filter viral_contigs.fasta checkv_output.tsv \\\n  --provirus \\\n  -o proviruses.fasta\n</code></pre>"},{"location":"cli/filter/#output-to-stdout","title":"Output to Stdout","text":"<p>Use in a pipeline:</p> <pre><code>votuderep filter viral_contigs.fasta checkv_output.tsv | \\\n  gzip &gt; filtered.fasta.gz\n</code></pre>"},{"location":"cli/filter/#checkv-quality-levels","title":"CheckV Quality Levels","text":"<p>CheckV assigns quality levels to viral contigs based on completeness and other metrics:</p> Quality Level Description Typical Use Complete Complete circular genomes or genomes with DTRs/ITRs Highest confidence analyses High-quality &gt;90% completeness Genome-level studies Medium-quality 50-90% completeness Most comparative analyses Low-quality &lt;50% completeness Large-scale surveys Not-determined Quality could not be assessed Usually excluded"},{"location":"cli/filter/#quality-filtering-behavior","title":"Quality Filtering Behavior","text":"<p>The <code>--min-quality</code> option is inclusive and hierarchical:</p> <ul> <li><code>--min-quality low</code>: Includes Low, Medium, High, and Complete</li> <li><code>--min-quality medium</code>: Includes Medium, High, and Complete</li> <li><code>--min-quality high</code>: Includes only High and Complete</li> </ul> <p>Note</p> <p>\"Not-determined\" sequences are included by default unless you use <code>--exclude-undetermined</code>.</p>"},{"location":"cli/filter/#filter-categories","title":"Filter Categories","text":""},{"location":"cli/filter/#length-filters","title":"Length Filters","text":"<ul> <li><code>--min-len</code>: Minimum contig length in base pairs</li> <li><code>--max-len</code>: Maximum contig length (0 = unlimited)</li> </ul> <p>Useful for: - Removing very short fragments - Focusing on typical viral genome sizes - Excluding potential chimeras or misassemblies</p>"},{"location":"cli/filter/#quality-filters","title":"Quality Filters","text":"<ul> <li><code>--min-quality</code>: Minimum CheckV quality level (low/medium/high)</li> <li><code>--complete</code>: Select only complete genomes</li> <li><code>--exclude-undetermined</code>: Exclude sequences where quality is \"Not-determined\"</li> </ul>"},{"location":"cli/filter/#metrics-filters","title":"Metrics Filters","text":"<ul> <li><code>--min-completeness</code>: Minimum completeness percentage (0-100)</li> <li><code>--max-contam</code>: Maximum contamination percentage (0-100)</li> <li><code>--no-warnings</code>: Only keep sequences with no CheckV warnings</li> </ul>"},{"location":"cli/filter/#provirus-filter","title":"Provirus Filter","text":"<ul> <li><code>--provirus</code>: Select only proviruses (integrated viral sequences)</li> </ul>"},{"location":"cli/filter/#practical-filtering-strategies","title":"Practical Filtering Strategies","text":""},{"location":"cli/filter/#conservative-approach","title":"Conservative Approach","text":"<p>For high-confidence downstream analyses:</p> <pre><code>votuderep filter contigs.fasta checkv.tsv \\\n  --min-quality high \\\n  --min-completeness 90 \\\n  --max-contam 5 \\\n  --no-warnings \\\n  -o conservative.fasta\n</code></pre>"},{"location":"cli/filter/#balanced-approach","title":"Balanced Approach","text":"<p>For most comparative genomics studies:</p> <pre><code>votuderep filter contigs.fasta checkv.tsv \\\n  --min-quality medium \\\n  --min-completeness 50 \\\n  --min-len 5000 \\\n  -o balanced.fasta\n</code></pre>"},{"location":"cli/filter/#permissive-approach","title":"Permissive Approach","text":"<p>For exploratory or large-scale surveys:</p> <pre><code>votuderep filter contigs.fasta checkv.tsv \\\n  --min-quality low \\\n  --min-len 3000 \\\n  -o permissive.fasta\n</code></pre>"},{"location":"cli/filter/#tips","title":"Tips","text":"<p>Pre-filtering for Dereplication</p> <p>It's recommended to filter sequences before running <code>derep</code> to:</p> <ol> <li>Reduce computational time</li> <li>Ensure dereplicated set contains only quality sequences</li> <li>Avoid clustering low-quality fragments with genuine sequences</li> </ol> <p>CheckV Output Format</p> <p>Make sure to provide the CheckV <code>quality_summary.tsv</code> file, not the contamination or completeness files. This file contains all the metrics needed for filtering.</p> <p>Combining with grep</p> <p>For complex filtering needs, you can combine with standard Unix tools: <pre><code>votuderep filter contigs.fasta checkv.tsv --min-quality medium | \\\n  grep -A 1 \"specific_pattern\"\n</code></pre></p>"},{"location":"cli/filter/#see-also","title":"See Also","text":"<ul> <li>derep - Dereplicate filtered sequences</li> <li>CheckV Documentation - Learn about CheckV metrics</li> <li>Quick Start Guide - Complete workflow examples</li> </ul>"},{"location":"cli/getdbs/","title":"votuderep getdbs","text":"<p>Download geNomad, CheckV, and PHROGs databases for viral sequence analysis.</p>"},{"location":"cli/getdbs/#overview","title":"Overview","text":"<p>The <code>getdbs</code> command simplifies database management by automatically downloading and setting up reference databases needed for viral genomics tools. It supports resumable downloads and validates database integrity.</p>"},{"location":"cli/getdbs/#usage","title":"Usage","text":"<pre><code>votuderep getdbs [OPTIONS]\n</code></pre>"},{"location":"cli/getdbs/#required-options","title":"Required Options","text":"<ul> <li><code>-o, --outdir PATH</code> - Directory where to download and extract databases</li> </ul>"},{"location":"cli/getdbs/#options","title":"Options","text":"<ul> <li><code>--force</code> - Allow using a non-empty output directory</li> <li><code>--db TEXT</code> - Database(s) to download: genomad_1.9, checkv_1.5, phrogs_4, or all (default: all). Can be repeated or comma-separated.</li> </ul>"},{"location":"cli/getdbs/#available-databases","title":"Available Databases","text":""},{"location":"cli/getdbs/#genomad-19","title":"geNomad 1.9","text":"<p>Purpose: Viral identification and classification</p> <p>Size: ~5 GB</p> <p>Description: Database for identifying viruses and plasmids in genomic and metagenomic data using the geNomad tool.</p> <p>Reference: geNomad GitHub</p>"},{"location":"cli/getdbs/#checkv-15","title":"CheckV 1.5","text":"<p>Purpose: Viral genome quality assessment</p> <p>Size: ~1.5 GB</p> <p>Description: Database for assessing the quality and completeness of viral genomes using the CheckV tool.</p> <p>Reference: CheckV on BitBucket</p>"},{"location":"cli/getdbs/#phrogs-4","title":"PHROGs 4","text":"<p>Purpose: Viral protein functional annotation</p> <p>Size: ~500 MB</p> <p>Description: Database of Prokaryotic Virus Remote Homologous Groups for annotating viral proteins.</p> <p>Reference: PHROGs</p>"},{"location":"cli/getdbs/#examples","title":"Examples","text":""},{"location":"cli/getdbs/#download-all-databases","title":"Download All Databases","text":"<p>Download all available databases to a directory:</p> <pre><code>votuderep getdbs -o ./databases/\n</code></pre> <p>This will create: <pre><code>databases/\n\u251c\u2500\u2500 genomad_db/\n\u251c\u2500\u2500 checkv-db-v1.5/\n\u2514\u2500\u2500 phrogs/\n</code></pre></p>"},{"location":"cli/getdbs/#download-specific-database","title":"Download Specific Database","text":"<p>Download only the database you need:</p> <pre><code># Only CheckV\nvotuderep getdbs -o ./databases/ --db checkv_1.5\n\n# Only geNomad\nvotuderep getdbs -o ./databases/ --db genomad_1.9\n\n# Only PHROGs\nvotuderep getdbs -o ./databases/ --db phrogs_4\n</code></pre>"},{"location":"cli/getdbs/#force-download-to-non-empty-directory","title":"Force Download to Non-Empty Directory","text":"<p>By default, the command checks if the output directory is empty. Use <code>--force</code> to override:</p> <pre><code>votuderep getdbs -o ./databases/ --force\n</code></pre> <p>Warning</p> <p>Using <code>--force</code> in a non-empty directory may overwrite existing files.</p>"},{"location":"cli/getdbs/#resume-interrupted-download","title":"Resume Interrupted Download","text":"<p>Downloads are automatically resumable. If a download is interrupted, simply run the command again:</p> <pre><code># First attempt (interrupted)\nvotuderep getdbs -o ./databases/ --db checkv_1.5\n\n# Resume (run the same command)\nvotuderep getdbs -o ./databases/ --db checkv_1.5\n</code></pre> <p>The command tracks download progress using marker files (<code>.downloading</code> and <code>.done</code>).</p>"},{"location":"cli/getdbs/#download-process","title":"Download Process","text":"<p>For each database, the command:</p> <ol> <li>Checks for existing complete download (<code>.done</code> marker)</li> <li>Downloads archive from the source URL</li> <li>Validates download (file size check)</li> <li>Extracts contents to the output directory</li> <li>Creates completion marker (<code>.done</code> file)</li> <li>Cleans up temporary files</li> </ol>"},{"location":"cli/getdbs/#storage-requirements","title":"Storage Requirements","text":"<p>Make sure you have sufficient disk space:</p> Database Compressed Extracted Total Required geNomad 1.9 ~1.5 GB ~5 GB ~6.5 GB CheckV 1.5 ~500 MB ~1.5 GB ~2 GB PHROGs 4 ~200 MB ~500 MB ~700 MB All ~2.2 GB ~7 GB ~9.2 GB <p>Disk Space</p> <p>The command needs space for both the compressed archive and extracted files during installation. After completion, compressed files are automatically deleted.</p>"},{"location":"cli/getdbs/#using-the-databases","title":"Using the Databases","text":"<p>After downloading, use the databases with their respective tools:</p>"},{"location":"cli/getdbs/#with-genomad","title":"With geNomad","text":"<pre><code>genomad end-to-end \\\n  --cleanup \\\n  --threads 8 \\\n  contigs.fasta \\\n  output_dir \\\n  ./databases/genomad_db\n</code></pre>"},{"location":"cli/getdbs/#with-checkv","title":"With CheckV","text":"<pre><code>checkv end_to_end \\\n  contigs.fasta \\\n  checkv_output \\\n  -d ./databases/checkv-db-v1.5 \\\n  -t 8\n</code></pre>"},{"location":"cli/getdbs/#with-phrogs","title":"With PHROGs","text":"<p>PHROGs is typically used with annotation tools that support the database format. Refer to the PHROGs documentation for integration with specific tools.</p>"},{"location":"cli/getdbs/#troubleshooting","title":"Troubleshooting","text":""},{"location":"cli/getdbs/#download-failures","title":"Download Failures","text":"<p>If a download fails repeatedly:</p> <ol> <li>Check your internet connection</li> <li>Try downloading a specific database instead of all</li> <li>Check if the source URL is accessible</li> <li>Ensure sufficient disk space</li> </ol>"},{"location":"cli/getdbs/#corrupted-downloads","title":"Corrupted Downloads","text":"<p>If you suspect a corrupted download:</p> <pre><code># Remove the .done marker\nrm ./databases/.checkv_1.5.done\n\n# Remove incomplete files\nrm -rf ./databases/checkv-db-v1.5/\n\n# Re-download\nvotuderep getdbs -o ./databases/ --db checkv_1.5\n</code></pre>"},{"location":"cli/getdbs/#permission-issues","title":"Permission Issues","text":"<p>Ensure you have write permissions in the output directory:</p> <pre><code># Check permissions\nls -ld ./databases/\n\n# Create directory with proper permissions if needed\nmkdir -p ./databases/\nchmod 755 ./databases/\n</code></pre>"},{"location":"cli/getdbs/#database-updates","title":"Database Updates","text":"<p>Database versions are specified in the command. To update to newer versions:</p> <ol> <li>Wait for votuderep to support the new version</li> <li>Download to a new directory</li> <li>Update your analysis scripts to use the new database path</li> </ol> <p>Version Tracking</p> <p>Each database version is tracked separately, allowing you to maintain multiple versions if needed.</p>"},{"location":"cli/getdbs/#network-considerations","title":"Network Considerations","text":""},{"location":"cli/getdbs/#proxy-settings","title":"Proxy Settings","text":"<p>If behind a proxy, configure your environment:</p> <pre><code>export http_proxy=http://proxy.example.com:8080\nexport https_proxy=http://proxy.example.com:8080\nvotuderep getdbs -o ./databases/\n</code></pre>"},{"location":"cli/getdbs/#timeout-issues","title":"Timeout Issues","text":"<p>For slow connections, the command will retry failed downloads automatically with exponential backoff.</p>"},{"location":"cli/getdbs/#see-also","title":"See Also","text":"<ul> <li>filter - Use CheckV output for filtering</li> <li>Quick Start Guide - Complete workflow with databases</li> <li>Installation - Setting up votuderep</li> </ul>"},{"location":"cli/splitcoverm/","title":"votuderep splitcoverm","text":"<p>Split CoverM TSV output by metric into separate files for easier downstream analysis.</p>"},{"location":"cli/splitcoverm/#overview","title":"Overview","text":"<p>The <code>splitcoverm</code> command processes CoverM output tables containing multiple coverage metrics across samples and splits them into individual TSV files\u2014one per metric. This simplifies downstream analysis by providing separate files for each metric (coverage, mean, variance, etc.).</p> <p>CoverM outputs tables where each sample has multiple metric columns. This command reorganizes the data so each metric gets its own file with samples as columns.</p>"},{"location":"cli/splitcoverm/#usage","title":"Usage","text":"<pre><code>votuderep splitcoverm [OPTIONS]\n</code></pre>"},{"location":"cli/splitcoverm/#required-options","title":"Required Options","text":"<ul> <li><code>-i, --input FILE</code> - Input CoverM TSV (optionally gzipped: .gz)</li> <li><code>-o, --output-basename TEXT</code> - Output basename/prefix for generated files</li> </ul>"},{"location":"cli/splitcoverm/#examples","title":"Examples","text":""},{"location":"cli/splitcoverm/#basic-usage","title":"Basic Usage","text":"<p>Split a CoverM output file:</p> <pre><code>votuderep splitcoverm -i coverage.tsv -o output/sample\n</code></pre> <p>Input file (<code>coverage.tsv</code>): <pre><code>Contig              Sample1 Mean  Sample1 Variance  Sample2 Mean  Sample2 Variance\ncontig_001          45.2          12.3             38.7          10.1\ncontig_002          67.8          15.9             72.3          14.2\n</code></pre></p> <p>Output files: - <code>output/sample_Mean.tsv</code> - <code>output/sample_Variance.tsv</code></p> <p>Output file (<code>output/sample_Mean.tsv</code>): <pre><code>Contig      Sample1  Sample2\ncontig_001  45.2     38.7\ncontig_002  67.8     72.3\n</code></pre></p>"},{"location":"cli/splitcoverm/#gzipped-input","title":"Gzipped Input","text":"<p>The command automatically handles gzipped input:</p> <pre><code>votuderep splitcoverm -i coverage.tsv.gz -o results/cov\n</code></pre>"},{"location":"cli/splitcoverm/#custom-output-path","title":"Custom Output Path","text":"<p>Specify a full path including directory and prefix:</p> <pre><code>votuderep splitcoverm \\\n  -i coverage.tsv \\\n  -o /path/to/results/experiment1_coverage\n</code></pre> <p>This creates files like: - <code>/path/to/results/experiment1_coverage_Mean.tsv</code> - <code>/path/to/results/experiment1_coverage_Variance.tsv</code></p>"},{"location":"cli/splitcoverm/#with-verbose-output","title":"With Verbose Output","text":"<p>See detailed processing information:</p> <pre><code>votuderep -v splitcoverm -i coverage.tsv -o output/prefix\n</code></pre>"},{"location":"cli/splitcoverm/#coverm-metrics","title":"CoverM Metrics","text":"<p>CoverM can calculate various coverage metrics. Common metrics you'll see in split files:</p> Metric Description Typical Use Mean Average coverage depth General abundance estimation Variance Coverage variance Quality/uniformity assessment Covered Bases Number of bases covered Breadth of coverage Covered Fraction Proportion of sequence covered Coverage completeness RPM Reads Per Million Normalized abundance RPKM Reads Per Kilobase Million Length-normalized abundance TPM Transcripts Per Million Relative abundance Trimmed Mean Mean after outlier removal Robust abundance estimate"},{"location":"cli/splitcoverm/#input-format-requirements","title":"Input Format Requirements","text":"<p>The command expects CoverM's standard TSV format:</p> <ol> <li>First column: Contig/sequence identifiers</li> <li>Remaining columns: Sample-metric pairs in format: <code>&lt;sample_name&gt; &lt;metric_name&gt;</code></li> <li>Header row: Column names (required)</li> <li>Tab-delimited: Fields separated by tabs</li> </ol> <p>Example header: <pre><code>Contig    Sample1 Mean    Sample1 Variance    Sample2 Mean    Sample2 Variance\n</code></pre></p>"},{"location":"cli/splitcoverm/#output-format","title":"Output Format","text":"<p>Each generated file:</p> <ul> <li>Filename: <code>&lt;basename&gt;_&lt;metric&gt;.tsv</code></li> <li>First column: Contig identifiers (from input)</li> <li>Other columns: One per sample (values for that metric)</li> <li>Tab-delimited: Standard TSV format</li> </ul>"},{"location":"cli/splitcoverm/#use-cases","title":"Use Cases","text":""},{"location":"cli/splitcoverm/#differential-abundance-analysis","title":"Differential Abundance Analysis","text":"<p>Split metrics for statistical analysis:</p> <pre><code># Split coverage file\nvotuderep splitcoverm -i coverage.tsv -o analysis/cov\n\n# Use mean coverage for differential abundance\nRscript differential_abundance.R analysis/cov_Mean.tsv\n</code></pre>"},{"location":"cli/splitcoverm/#heatmap-visualization","title":"Heatmap Visualization","text":"<p>Create heatmaps for specific metrics:</p> <pre><code># Split file\nvotuderep splitcoverm -i coverage.tsv -o viz/data\n\n# Generate heatmap from mean coverage\npython plot_heatmap.py viz/data_Mean.tsv -o mean_coverage_heatmap.png\n</code></pre>"},{"location":"cli/splitcoverm/#metric-comparison","title":"Metric Comparison","text":"<p>Compare different metrics for quality control:</p> <pre><code>votuderep splitcoverm -i coverage.tsv -o qc/metrics\n\n# Compare mean vs trimmed mean\nRscript compare_metrics.R \\\n  qc/metrics_Mean.tsv \\\n  qc/metrics_TrimmedMean.tsv\n</code></pre>"},{"location":"cli/splitcoverm/#integration-with-rpython","title":"Integration with R/Python","text":"<p>Simplify data loading in analysis scripts:</p> <p>R example: <pre><code># After splitting\nmean_cov &lt;- read.table(\"output/sample_Mean.tsv\", header=TRUE, sep=\"\\t\")\nvariance &lt;- read.table(\"output/sample_Variance.tsv\", header=TRUE, sep=\"\\t\")\n\n# Proceed with analysis\n</code></pre></p> <p>Python example: <pre><code>import pandas as pd\n\n# After splitting\nmean_df = pd.read_csv(\"output/sample_Mean.tsv\", sep=\"\\t\")\nvariance_df = pd.read_csv(\"output/sample_Variance.tsv\", sep=\"\\t\")\n\n# Proceed with analysis\n</code></pre></p>"},{"location":"cli/splitcoverm/#filtering-and-selection","title":"Filtering and Selection","text":"<p>Extract only the metrics you need:</p> <pre><code># Split all metrics\nvotuderep splitcoverm -i coverage.tsv -o all/data\n\n# Use only mean coverage for downstream analysis\ncp all/data_Mean.tsv analysis/abundance.tsv\n</code></pre>"},{"location":"cli/splitcoverm/#advanced-examples","title":"Advanced Examples","text":""},{"location":"cli/splitcoverm/#batch-processing","title":"Batch Processing","text":"<p>Process multiple CoverM outputs:</p> <pre><code>for file in coverm_outputs/*.tsv; do\n  basename=$(basename \"$file\" .tsv)\n  votuderep splitcoverm -i \"$file\" -o \"split_metrics/$basename\"\ndone\n</code></pre>"},{"location":"cli/splitcoverm/#pipeline-integration","title":"Pipeline Integration","text":"<p>Use in a pipeline with CoverM:</p> <pre><code># Run CoverM\ncoverm contig \\\n  -r reference.fasta \\\n  -b *.bam \\\n  -m mean variance covered_fraction \\\n  &gt; coverage.tsv\n\n# Split metrics\nvotuderep splitcoverm -i coverage.tsv -o results/coverage\n\n# Continue with analysis\nRscript analyze_abundance.R results/coverage_Mean.tsv\n</code></pre>"},{"location":"cli/splitcoverm/#compress-output","title":"Compress Output","text":"<p>Create compressed output files:</p> <pre><code># Split files\nvotuderep splitcoverm -i coverage.tsv -o results/cov\n\n# Compress individually\ngzip results/cov_*.tsv\n\n# Or compress all at once\nfind results/ -name \"cov_*.tsv\" -exec gzip {} \\;\n</code></pre>"},{"location":"cli/splitcoverm/#output-organization","title":"Output Organization","text":"<p>For better organization, use descriptive basenames:</p> <pre><code># Good: descriptive basename\nvotuderep splitcoverm \\\n  -i coverage.tsv \\\n  -o results/projectX_viral_contigs_coverage\n\n# Creates:\n# results/projectX_viral_contigs_coverage_Mean.tsv\n# results/projectX_viral_contigs_coverage_Variance.tsv\n</code></pre>"},{"location":"cli/splitcoverm/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Large files: Processing time scales with file size</li> <li>Memory: The entire table is loaded into memory</li> <li>Gzipped input: Slightly slower but saves disk space</li> <li>Output: All output files written simultaneously</li> </ul> <p>For very large files: <pre><code># Use verbose mode to monitor progress\nvotuderep -v splitcoverm -i large_file.tsv.gz -o output/prefix\n\n# Consider working on a fast filesystem (SSD)\n</code></pre></p>"},{"location":"cli/splitcoverm/#troubleshooting","title":"Troubleshooting","text":""},{"location":"cli/splitcoverm/#format-errors","title":"Format Errors","text":"<p>If you get a format error:</p> <ol> <li>Check input format: Ensure it's CoverM output TSV</li> <li>Verify tab-delimited: Some tools output space-delimited</li> <li>Check header: Must have proper column names</li> <li>Inspect file: <pre><code>head -n 2 coverage.tsv | cat -A\n</code></pre></li> </ol>"},{"location":"cli/splitcoverm/#no-output-files","title":"No Output Files","text":"<p>If no files are generated:</p> <ol> <li>Check input exists: <code>ls -lh coverage.tsv</code></li> <li>Verify output directory exists or is writable</li> <li>Use verbose mode: <code>votuderep -v splitcoverm ...</code></li> <li>Check for error messages</li> </ol>"},{"location":"cli/splitcoverm/#unexpected-metric-names","title":"Unexpected Metric Names","text":"<p>If metric names in output filenames look wrong:</p> <ul> <li>Check the CoverM command that generated the input</li> <li>The metric names come directly from CoverM column headers</li> <li>Spaces in metric names will be preserved in filenames</li> </ul>"},{"location":"cli/splitcoverm/#memory-issues","title":"Memory Issues","text":"<p>For very large files:</p> <pre><code># Check file size first\nls -lh coverage.tsv\n\n# If too large, consider splitting the input first\nsplit -l 100000 coverage.tsv coverage_part_\n\n# Process each part\nfor part in coverage_part_*; do\n  votuderep splitcoverm -i \"$part\" -o \"results/${part}\"\ndone\n</code></pre>"},{"location":"cli/splitcoverm/#tips","title":"Tips","text":"<p>Check CoverM Output First</p> <p>Before splitting, inspect your CoverM output to understand what metrics are included: <pre><code>head -n 1 coverage.tsv | tr '\\t' '\\n'\n</code></pre></p> <p>Consistent Naming</p> <p>Use consistent basename patterns for easier file management: <pre><code>votuderep splitcoverm -i sample1.tsv -o split/sample1_cov\nvotuderep splitcoverm -i sample2.tsv -o split/sample2_cov\n</code></pre></p> <p>Automate with Make</p> <p>For reproducible workflows, use Make: <pre><code>split/%.tsv: coverm/%.tsv\n    votuderep splitcoverm -i $&lt; -o split/$(basename $&lt;)\n</code></pre></p>"},{"location":"cli/splitcoverm/#integration-with-coverm","title":"Integration with CoverM","text":"<p>CoverM is a tool for calculating coverage metrics from BAM files. Typical workflow:</p> <pre><code># 1. Map reads to contigs (using tools like BWA, Bowtie2)\nbwa mem ref.fasta sample_R1.fq sample_R2.fq | samtools sort -o sample.bam\n\n# 2. Run CoverM to calculate metrics\ncoverm contig \\\n  -b sample1.bam sample2.bam \\\n  -m mean variance rpkm \\\n  &gt; coverage.tsv\n\n# 3. Split by metric\nvotuderep splitcoverm -i coverage.tsv -o analysis/coverage\n\n# 4. Analyze individual metrics\nRscript analyze.R analysis/coverage_Mean.tsv\n</code></pre>"},{"location":"cli/splitcoverm/#see-also","title":"See Also","text":"<ul> <li>CoverM Documentation - Learn about CoverM</li> <li>Quick Start Guide - Complete workflow examples</li> <li>derep - Dereplicate sequences after abundance analysis</li> </ul>"},{"location":"cli/tabulate/","title":"votuderep tabulate","text":"<p>Generate CSV tables from paired-end sequencing read directories.</p>"},{"location":"cli/tabulate/#overview","title":"Overview","text":"<p>The <code>tabulate</code> command scans a directory containing paired-end sequencing reads and generates a structured CSV table. This is particularly useful for creating sample sheets for workflow managers like Nextflow, Snakemake, or custom scripts.</p>"},{"location":"cli/tabulate/#usage","title":"Usage","text":"<pre><code>votuderep tabulate [OPTIONS] INPUT_DIR\n</code></pre>"},{"location":"cli/tabulate/#required-arguments","title":"Required Arguments","text":"<ul> <li><code>INPUT_DIR</code> - Directory containing sequencing read files</li> </ul>"},{"location":"cli/tabulate/#options","title":"Options","text":"<ul> <li><code>-o, --output FILE</code> - Output CSV file (default: STDOUT)</li> <li><code>-d, --delimiter TEXT</code> - Field separator (default: ,)</li> <li><code>-1, --for-tag TEXT</code> - Identifier for forward reads (default: _R1)</li> <li><code>-2, --rev-tag TEXT</code> - Identifier for reverse reads (default: _R2)</li> <li><code>-s, --strip TEXT</code> - Remove this string from sample names (can be used multiple times)</li> <li><code>-e, --extension TEXT</code> - Only process files ending with this extension</li> <li><code>-a, --absolute</code> - Use absolute paths in output</li> </ul>"},{"location":"cli/tabulate/#examples","title":"Examples","text":""},{"location":"cli/tabulate/#basic-usage","title":"Basic Usage","text":"<p>Generate a CSV table from a reads directory:</p> <pre><code>votuderep tabulate reads/ -o samples.csv\n</code></pre> <p>Input directory structure: <pre><code>reads/\n\u251c\u2500\u2500 sample1_R1.fastq.gz\n\u251c\u2500\u2500 sample1_R2.fastq.gz\n\u251c\u2500\u2500 sample2_R1.fastq.gz\n\u2514\u2500\u2500 sample2_R2.fastq.gz\n</code></pre></p> <p>Output CSV: <pre><code>sample,R1,R2\nsample1,reads/sample1_R1.fastq.gz,reads/sample1_R2.fastq.gz\nsample2,reads/sample2_R1.fastq.gz,reads/sample2_R2.fastq.gz\n</code></pre></p>"},{"location":"cli/tabulate/#custom-read-tags","title":"Custom Read Tags","text":"<p>If your files use different naming conventions:</p> <pre><code>votuderep tabulate reads/ \\\n  --for-tag _1.fq.gz \\\n  --rev-tag _2.fq.gz \\\n  -o samples.csv\n</code></pre> <p>This will match: - <code>sample_1.fq.gz</code> (forward) - <code>sample_2.fq.gz</code> (reverse)</p>"},{"location":"cli/tabulate/#filter-by-extension","title":"Filter by Extension","text":"<p>Process only files with specific extension:</p> <pre><code>votuderep tabulate reads/ \\\n  --extension .fastq.gz \\\n  -o samples.csv\n</code></pre>"},{"location":"cli/tabulate/#absolute-paths","title":"Absolute Paths","text":"<p>Use absolute paths in the output (useful for workflow managers):</p> <pre><code>votuderep tabulate reads/ \\\n  --absolute \\\n  -o samples.csv\n</code></pre> <p>Output with absolute paths: <pre><code>sample,R1,R2\nsample1,/full/path/to/reads/sample1_R1.fastq.gz,/full/path/to/reads/sample1_R2.fastq.gz\n</code></pre></p>"},{"location":"cli/tabulate/#strip-patterns-from-sample-names","title":"Strip Patterns from Sample Names","text":"<p>Remove unwanted patterns from sample names:</p> <pre><code>votuderep tabulate reads/ \\\n  --strip \"Sample_\" \\\n  --strip \".filtered\" \\\n  -o samples.csv\n</code></pre> <p>Example: - Input: <code>Sample_001.filtered_R1.fastq.gz</code> - Output sample name: <code>001</code></p> <p>Multiple <code>--strip</code> options are processed in order.</p>"},{"location":"cli/tabulate/#tab-delimited-output","title":"Tab-Delimited Output","text":"<p>Use tabs instead of commas:</p> <pre><code>votuderep tabulate reads/ \\\n  --delimiter $'\\t' \\\n  -o samples.tsv\n</code></pre>"},{"location":"cli/tabulate/#output-to-stdout","title":"Output to Stdout","text":"<p>For piping to other commands:</p> <pre><code>votuderep tabulate reads/ | head -n 5\n</code></pre>"},{"location":"cli/tabulate/#read-pair-detection","title":"Read Pair Detection","text":"<p>The command automatically pairs forward and reverse reads based on the tags:</p> <ol> <li>Scans directory for files matching the extension filter (if specified)</li> <li>Identifies forward reads containing the forward tag (default: <code>_R1</code>)</li> <li>Finds corresponding reverse reads by replacing forward tag with reverse tag (default: <code>_R2</code>)</li> <li>Extracts sample name by removing the forward tag and extension</li> <li>Applies strip patterns to clean up sample names</li> </ol>"},{"location":"cli/tabulate/#naming-requirements","title":"Naming Requirements","text":"<p>For successful pairing:</p> <ul> <li>Forward and reverse files must have identical names except for the R1/R2 tag</li> <li>Tags must be unique in the filename</li> <li>Both files in a pair must exist</li> </ul> <p>Unpaired Reads</p> <p>If a forward read file is found without a corresponding reverse read, that sample will be skipped with a warning message.</p>"},{"location":"cli/tabulate/#use-cases","title":"Use Cases","text":""},{"location":"cli/tabulate/#nextflow-sample-sheet","title":"Nextflow Sample Sheet","text":"<p>Create a sample sheet for Nextflow pipelines:</p> <pre><code>votuderep tabulate reads/ \\\n  --absolute \\\n  --strip \"Sample_\" \\\n  -o samplesheet.csv\n</code></pre> <p>Use in Nextflow: <pre><code>Channel\n    .fromPath('samplesheet.csv')\n    .splitCsv(header: true)\n    .map { row -&gt; tuple(row.sample, file(row.R1), file(row.R2)) }\n    .set { samples_ch }\n</code></pre></p>"},{"location":"cli/tabulate/#snakemake-configuration","title":"Snakemake Configuration","text":"<p>Generate a sample table for Snakemake:</p> <pre><code>votuderep tabulate reads/ \\\n  --delimiter $'\\t' \\\n  -o config/samples.tsv\n</code></pre>"},{"location":"cli/tabulate/#quality-control-verification","title":"Quality Control Verification","text":"<p>List all paired reads for verification:</p> <pre><code>votuderep tabulate reads/ | column -t -s,\n</code></pre>"},{"location":"cli/tabulate/#subset-selection","title":"Subset Selection","text":"<p>Extract specific samples:</p> <pre><code>votuderep tabulate reads/ | grep \"control\\|treatment\"\n</code></pre>"},{"location":"cli/tabulate/#advanced-examples","title":"Advanced Examples","text":""},{"location":"cli/tabulate/#complex-naming-convention","title":"Complex Naming Convention","text":"<p>For files like <code>ProjectX_Sample001_Lane1_R1_001.fastq.gz</code>:</p> <pre><code>votuderep tabulate reads/ \\\n  --for-tag _R1_001 \\\n  --rev-tag _R2_001 \\\n  --strip \"ProjectX_\" \\\n  --strip \"_Lane1\" \\\n  -o samples.csv\n</code></pre> <p>Result: - Sample name: <code>Sample001</code> - Matched pairs properly identified</p>"},{"location":"cli/tabulate/#multiple-read-directories","title":"Multiple Read Directories","text":"<p>Combine reads from multiple directories:</p> <pre><code># Create separate CSVs\nvotuderep tabulate batch1/ -o batch1.csv\nvotuderep tabulate batch2/ -o batch2.csv\n\n# Combine (skip first header)\ncat batch1.csv &gt; all_samples.csv\ntail -n +2 batch2.csv &gt;&gt; all_samples.csv\n</code></pre>"},{"location":"cli/tabulate/#validation-script","title":"Validation Script","text":"<p>Generate table and validate pairs exist:</p> <pre><code>votuderep tabulate reads/ -o samples.csv\n\n# Verify all files exist\ntail -n +2 samples.csv | cut -d',' -f2,3 | tr ',' '\\n' | while read file; do\n  [ -f \"$file\" ] || echo \"Missing: $file\"\ndone\n</code></pre>"},{"location":"cli/tabulate/#output-format","title":"Output Format","text":"<p>The generated CSV always has three columns:</p> Column Description Example <code>sample</code> Sample identifier (basename without R1/R2 and extension) <code>sample1</code> <code>R1</code> Path to forward read file <code>reads/sample1_R1.fastq.gz</code> <code>R2</code> Path to reverse read file <code>reads/sample1_R2.fastq.gz</code>"},{"location":"cli/tabulate/#tips","title":"Tips","text":"<p>Testing Patterns</p> <p>Before generating the final table, test your strip patterns: <pre><code>votuderep tabulate reads/ --strip \"pattern\" | head -n 3\n</code></pre></p> <p>Duplicate Sample Names</p> <p>If multiple file pairs resolve to the same sample name after stripping, only the last one will be included. Use <code>--verbose</code> to see warnings.</p> <p>Relative vs Absolute Paths</p> <ul> <li>Use relative paths (default) for portable sample sheets</li> <li>Use absolute paths (<code>--absolute</code>) for workflow managers or when reads are in different locations</li> </ul>"},{"location":"cli/tabulate/#common-issues","title":"Common Issues","text":""},{"location":"cli/tabulate/#no-pairs-found","title":"No Pairs Found","text":"<p>If no pairs are detected:</p> <ol> <li>Check your read tags match the files: <code>ls reads/*R1*</code></li> <li>Try without extension filter: remove <code>--extension</code></li> <li>Use verbose mode to see what's being processed: <code>-v</code></li> </ol>"},{"location":"cli/tabulate/#wrong-sample-names","title":"Wrong Sample Names","text":"<p>If sample names aren't what you expect:</p> <ol> <li>Check what's being detected: <code>votuderep tabulate reads/ | cat</code></li> <li>Add strip patterns to remove unwanted parts</li> <li>Adjust the for-tag and rev-tag if needed</li> </ol>"},{"location":"cli/tabulate/#files-in-subdirectories","title":"Files in Subdirectories","text":"<p>The command only searches the specified directory, not subdirectories. To process subdirectories:</p> <pre><code># Process each subdirectory separately\nfor dir in reads/*/; do\n  votuderep tabulate \"$dir\" &gt;&gt; all_samples.csv\ndone\n</code></pre>"},{"location":"cli/tabulate/#see-also","title":"See Also","text":"<ul> <li>Quick Start Guide - Using tabulate in workflows</li> <li>trainingdata - Download example sequencing data</li> </ul>"},{"location":"cli/trainingdata/","title":"votuderep trainingdata","text":"<p>Download viral assembly and sequencing read datasets for training and testing purposes.</p>"},{"location":"cli/trainingdata/#overview","title":"Overview","text":"<p>The <code>trainingdata</code> command downloads example datasets from the EBAME (Empowering Biodiversity through Metagenomics) workshop. These datasets are useful for learning, testing workflows, and benchmarking viral analysis pipelines.</p>"},{"location":"cli/trainingdata/#usage","title":"Usage","text":"<pre><code>votuderep trainingdata [OPTIONS]\n</code></pre>"},{"location":"cli/trainingdata/#options","title":"Options","text":"<ul> <li><code>-o, --outdir TEXT</code> - Where to put the output files (default: ./ebame-virome/)</li> <li><code>-n, --name TEXT</code> - Dataset name to download (registered in DATASETS) (default: virome)</li> </ul>"},{"location":"cli/trainingdata/#examples","title":"Examples","text":""},{"location":"cli/trainingdata/#download-to-default-location","title":"Download to Default Location","text":"<p>Download all training data to the default directory:</p> <pre><code>votuderep trainingdata\n</code></pre> <p>This creates: <code>./ebame-virome/</code></p>"},{"location":"cli/trainingdata/#download-to-custom-location","title":"Download to Custom Location","text":"<p>Specify a custom output directory:</p> <pre><code>votuderep trainingdata -o ./training_data/\n</code></pre>"},{"location":"cli/trainingdata/#with-verbose-output","title":"With Verbose Output","text":"<p>See detailed progress information:</p> <pre><code>votuderep -v trainingdata -o ./data/\n</code></pre>"},{"location":"cli/trainingdata/#included-datasets","title":"Included Datasets","text":""},{"location":"cli/trainingdata/#1-viral-assembly","title":"1. Viral Assembly","text":"<p>Source: Zenodo Type: Assembled viral contigs Format: FASTA Description: Human gut virome assembly for testing viral sequence analysis tools</p> <p>Typical Uses: - Testing viral identification tools (geNomad, VirSorter) - Benchmarking CheckV quality assessment - Testing dereplication with <code>votuderep derep</code> - Practicing filtering with <code>votuderep filter</code></p>"},{"location":"cli/trainingdata/#2-sequencing-reads","title":"2. Sequencing Reads","text":"<p>Source: EBI Short Read Archive (SRA) Type: Paired-end sequencing reads Format: FASTQ (gzipped) Samples: 3 samples from human gut virome study</p> <p>Sample IDs: - ERR6797443 (R1 &amp; R2) - ERR6797444 (R1 &amp; R2) - ERR6797445 (R1 &amp; R2)</p> <p>Typical Uses: - Testing read quality control pipelines - Practicing assembly workflows - Benchmarking mapping tools - Testing <code>votuderep tabulate</code> for sample sheet generation</p>"},{"location":"cli/trainingdata/#output-structure","title":"Output Structure","text":"<p>After downloading, your directory will contain:</p> <pre><code>ebame-virome/\n\u251c\u2500\u2500 assembly/\n\u2502   \u2514\u2500\u2500 viral_contigs.fasta\n\u2514\u2500\u2500 reads/\n    \u251c\u2500\u2500 ERR6797443_R1.fastq.gz\n    \u251c\u2500\u2500 ERR6797443_R2.fastq.gz\n    \u251c\u2500\u2500 ERR6797444_R1.fastq.gz\n    \u251c\u2500\u2500 ERR6797444_R2.fastq.gz\n    \u251c\u2500\u2500 ERR6797445_R1.fastq.gz\n    \u2514\u2500\u2500 ERR6797445_R2.fastq.gz\n</code></pre>"},{"location":"cli/trainingdata/#example-workflows","title":"Example Workflows","text":""},{"location":"cli/trainingdata/#test-complete-pipeline","title":"Test Complete Pipeline","text":"<p>Use the downloaded data to test a complete viral analysis pipeline:</p> <pre><code># 1. Download training data\nvotuderep trainingdata -o ./tutorial/\n\n# 2. Run CheckV on the assembly (requires CheckV installed)\ncheckv end_to_end \\\n  ./tutorial/assembly/viral_contigs.fasta \\\n  ./tutorial/checkv_out/ \\\n  -d ./databases/checkv-db-v1.5\n\n# 3. Filter based on quality\nvotuderep filter \\\n  ./tutorial/assembly/viral_contigs.fasta \\\n  ./tutorial/checkv_out/quality_summary.tsv \\\n  --min-quality medium \\\n  -o ./tutorial/filtered.fasta\n\n# 4. Dereplicate\nvotuderep derep \\\n  -i ./tutorial/filtered.fasta \\\n  -o ./tutorial/dereplicated.fasta \\\n  -t 4\n</code></pre>"},{"location":"cli/trainingdata/#test-read-processing","title":"Test Read Processing","text":"<p>Practice working with sequencing reads:</p> <pre><code># 1. Download training data\nvotuderep trainingdata -o ./tutorial/\n\n# 2. Generate sample sheet\nvotuderep tabulate ./tutorial/reads/ -o samples.csv\n\n# 3. Run quality control (requires FastQC)\ncat samples.csv | tail -n +2 | cut -d',' -f2,3 | tr ',' '\\n' | \\\n  xargs fastqc -o qc_reports/\n\n# 4. Assemble reads (requires assembler like SPAdes or MEGAHIT)\n# ... your assembly command ...\n</code></pre>"},{"location":"cli/trainingdata/#benchmarking","title":"Benchmarking","text":"<p>Test performance and compare parameters:</p> <pre><code># Download data\nvotuderep trainingdata -o ./bench/\n\n# Test different ANI thresholds\nfor ani in 90 95 97 99; do\n  echo \"Testing ANI=$ani\"\n  time votuderep derep \\\n    -i ./bench/assembly/viral_contigs.fasta \\\n    -o ./bench/derep_ani${ani}.fasta \\\n    --min-ani $ani \\\n    -t 8\n\n  # Count resulting sequences\n  grep -c \"^&gt;\" ./bench/derep_ani${ani}.fasta\ndone\n</code></pre>"},{"location":"cli/trainingdata/#dataset-information","title":"Dataset Information","text":""},{"location":"cli/trainingdata/#assembly-dataset","title":"Assembly Dataset","text":"<p>The viral assembly dataset represents typical output from viral contig identification in metagenomic samples. It includes:</p> <ul> <li>Various contig lengths (representing complete and partial genomes)</li> <li>Different quality levels (as would be assessed by CheckV)</li> <li>Multiple viral families and diversity</li> </ul>"},{"location":"cli/trainingdata/#read-datasets","title":"Read Datasets","text":"<p>The sequencing read datasets are from human gut virome studies and include:</p> <ul> <li>Paired-end Illumina reads</li> <li>Typical read lengths (~150 bp)</li> <li>Representative coverage depths</li> <li>Real-world complexity and diversity</li> </ul> <p>Data Size</p> <p>The complete training dataset is approximately 1-2 GB. Ensure you have sufficient disk space and a stable internet connection for downloading.</p>"},{"location":"cli/trainingdata/#download-process","title":"Download Process","text":"<p>The command:</p> <ol> <li>Creates output directory if it doesn't exist</li> <li>Downloads assembly from Zenodo</li> <li>Downloads reads from EBI SRA (6 files: 3 samples \u00d7 2 reads)</li> <li>Validates downloads (checksums where available)</li> <li>Organizes files into assembly/ and reads/ subdirectories</li> </ol> <p>Downloads are resumable - if interrupted, run the command again to continue.</p>"},{"location":"cli/trainingdata/#storage-requirements","title":"Storage Requirements","text":"Component Size Description Assembly ~100 MB Viral contigs FASTA Reads (total) ~1.5 GB 3 samples, paired-end, gzipped Total ~1.6 GB Complete training dataset"},{"location":"cli/trainingdata/#using-with-workshop-materials","title":"Using with Workshop Materials","text":"<p>This data is designed to work with the EBAME workshop materials:</p> <pre><code># Download data\nvotuderep trainingdata -o ~/ebame_tutorial/\n\n# Follow workshop tutorials using this data\n# https://maignienlab.gitlab.io/ebame/\n</code></pre>"},{"location":"cli/trainingdata/#troubleshooting","title":"Troubleshooting","text":""},{"location":"cli/trainingdata/#download-failures","title":"Download Failures","text":"<p>If downloads fail:</p> <ol> <li>Check internet connection</li> <li>Verify URLs are accessible (try in browser)</li> <li>Run with verbose flag to see detailed error messages:    <pre><code>votuderep -v trainingdata\n</code></pre></li> <li>Resume download by running the command again</li> </ol>"},{"location":"cli/trainingdata/#disk-space-issues","title":"Disk Space Issues","text":"<p>Ensure sufficient space before downloading:</p> <pre><code># Check available space\ndf -h .\n\n# If needed, use different location with more space\nvotuderep trainingdata -o /path/to/larger/disk/\n</code></pre>"},{"location":"cli/trainingdata/#slow-downloads","title":"Slow Downloads","text":"<p>For slow connections:</p> <ul> <li>The command will retry failed downloads automatically</li> <li>Consider downloading during off-peak hours</li> <li>You can interrupt and resume downloads as needed</li> </ul>"},{"location":"cli/trainingdata/#corrupted-files","title":"Corrupted Files","text":"<p>If you suspect corrupted downloads:</p> <pre><code># Remove the output directory\nrm -rf ./ebame-virome/\n\n# Re-download\nvotuderep trainingdata\n</code></pre>"},{"location":"cli/trainingdata/#data-citation","title":"Data Citation","text":"<p>If you use this training data in publications, please cite:</p> <ul> <li>EBAME Workshop: https://maignienlab.gitlab.io/ebame/</li> <li>Original data sources: Check the individual dataset repositories on Zenodo and EBI for specific citations</li> </ul>"},{"location":"cli/trainingdata/#see-also","title":"See Also","text":"<ul> <li>tabulate - Generate sample sheets from the downloaded reads</li> <li>derep - Test dereplication on the assembly</li> <li>filter - Practice filtering with CheckV results</li> <li>Quick Start Guide - Complete workflow examples</li> </ul>"}]}